<!DOCTYPE html>
<html lang="th">
<head>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+Thai:wght@400;700&display=swap" rel="stylesheet">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NUCE</title>
    <link rel="stylesheet" href="style.css">
    <script type="text/javascript" src="https://api.longdo.com/map/?key=365a698c226f1b77c3218bb30fbf6181"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.6.2/proj4.js"></script> 
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.4.0/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.3.2/html2canvas.min.js"></script>
    <link rel="icon" type="image/png" sizes="12x12" href="https://i.postimg.cc/VkVjXhz2/2015-color-en.png">
</head>
<body onload="initMap();">
    
    <!--navbar-->
    <div class="navbar">
        <header class="header-content">
            <img src="https://i.postimg.cc/VkVjXhz2/2015-color-en.png" alt="Logo" style="width: 50px; height: auto;">
            <button class="button-66 lang" data-key="manualButton48" id="myButton" role="button">Manualüìñ</button>

        </header>
        <div class="steps-buttons">
            <button class="step-btna lang" data-key="step1" onclick="showStep(1)">Step 1</button>
            <button class="step-btna lang" data-key="step2" onclick="showStep(2)">Step 2</button>
            <button class="step-btna lang" data-key="step3" onclick="showStep(3)">Step 3</button>
            <button class="step-btna lang" data-key="step4" onclick="showStep(4)">Step 4</button>
            <button class="step-btna lang" data-key="step5" onclick="showStep(5)">Step 5</button>
        </div>
        <div class="language-contract-buttons">
            <button class="contract" onclick="goToLink()" style="margin-right: 10px;">contact</button>
        <button class="change-language-btn lang" data-key="changeLanguageButton" onclick="changeLanguage()">‡∏†‡∏≤‡∏©‡∏≤:‡πÑ‡∏ó‡∏¢</button>
        </div>
    </div>
    
    <!--step1-->
    <div id="step1" class="step">
        <h2 class="lang" data-key="step1Title">Step 1: ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠‡∏´‡∏°‡∏∏‡∏î</h2>
        <input type="text" id="pinName" class="lang-placeholder" data-key="pinNamePlaceholder" onkeypress="handleKeyPress(event)">
        <button onclick="addPin()" class="add-btn lang" data-key="addButton">‡πÄ‡∏û‡∏¥‡πà‡∏°</button>
        <input type="file" id="importFile" accept=".xlsx, .xls" />
        <button onclick="importExcelData()" class="add-btn lang" data-key="importData">ImportData</button>
        <button class="add-btn lang" data-key="exportPinsButton" onclick="exportStepsToExcel()">Export to Excel</button>
        <table id="pinTable">
            <tr>
                <th>‡∏•‡∏≥‡∏î‡∏±‡∏ö</th>
                <th>‡∏ä‡∏∑‡πà‡∏≠‡∏´‡∏°‡∏∏‡∏î</th>
                <th>‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏∞‡∏ó‡∏≥</th>
            </tr>
            <!-- Rows will be added here by JavaScript -->
        </table>
    </div>

     <!--step2-->
    <div id="step2" class="step" style="display: none;">
        <h2 class="lang" data-key="step2Title">Step 2: ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏£‡∏±‡∏á‡∏ß‡∏±‡∏î‡∏°‡∏∏‡∏°‡∏†‡∏≤‡∏¢‡πÉ‡∏ô</h2>
        <!-- Dropdowns for selecting pins -->
        <div>
            <span class="lang" data-key="stationCamera">‡∏´‡∏°‡∏∏‡∏î‡∏ï‡∏±‡πâ‡∏á‡∏Å‡∏•‡πâ‡∏≠‡∏á:</span> <select id="stationSelect"></select>
        <span class="lang" data-key="object1">‡∏´‡∏°‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏™‡πà‡∏≠‡∏á1:</span> <select id="object1Select"></select>
        <span class="lang" data-key="object2">‡∏´‡∏°‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏™‡πà‡∏≠‡∏á2:</span> <select id="object2Select"></select>
        <button class="step-btn lang" data-key="createTable" onclick="createSurveyTable()">‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ï‡∏≤‡∏£‡∏≤‡∏á</button>
        
        <button onclick="importSurveyTable()">Import Table</button>
        <button onclick="importSurveyTableHAHD()">Import Survey Data HAHD</button>
        <!-- Dropdown ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏ï‡∏≤‡∏°‡∏ä‡∏∑‡πà‡∏≠‡∏™‡∏ñ‡∏≤‡∏ô‡∏µ -->
        <button class="add-btn lang" data-key="exportStepsExcel"onclick="exportStepsToExcel()">Export Steps 1 & 2 to Excel</button>
        <select id="tableSelect">
        <!-- ‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÇ‡∏î‡∏¢ JavaScript -->
        </select>

        <!-- ‡∏õ‡∏∏‡πà‡∏°‡∏•‡∏ö‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å -->
        <button id="deleteButton" class="delete-style lang" data-key="deleteTable" onclick="deleteSelectedTable()">‡∏•‡∏ö</button>
        <!-- Export Button -->
        </div>
        <div id="surveyTables">
            <!-- Survey tables will be added here by JavaScript -->
        </div>
        <div>
            <table id="hdDataTable" class="hidden">
                <!-- ... ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏≤‡∏£‡∏≤‡∏á HD ... -->
              </table>
              
              <table id="averageHDDataTable">
                <!-- ... ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢ HD ... -->
              </table>
        </div>
        <table id="swappedAverageHDTable">
            <tr>
              <th>Station 1</th>
              <th>Object 1</th>
              <th>Station 2</th>
              <th>Object 2</th>
              <th>Swapped Average HD</th>
            </tr>
            <!-- ‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡πÄ‡∏ï‡∏¥‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏î‡πâ‡∏ß‡∏¢ JavaScript -->
          </table>

          <table id="finalHDTable">
            <!-- ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡πÄ‡∏ï‡∏¥‡∏°‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà‡πÇ‡∏î‡∏¢ JavaScript -->
          </table>
          
          

    </div>

     <!--step3-->
    <div id="step3" class="step" style="display: none;">
        <h2 class="lang" data-key="step3Title">Step 3: ‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏£‡∏±‡∏á‡∏ß‡∏±‡∏î‡∏°‡∏∏‡∏°‡∏†‡∏≤‡∏¢‡πÉ‡∏ô</h2>

        <button class="add-btn lang" data-key="exportToExcel" onclick="exportStepsToExcel()">Export to Excel</button>
        <table id="measurementTable">
            <!-- ‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏î‡∏¢ JavaScript -->
        </table>
        <!-- ‡∏õ‡∏∏‡πà‡∏°‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏•‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏• -->
        <button class="standard1 lang" data-key="standardButton" onclick="toggleImage()">‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô</button>

        <!-- ‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏™‡∏•‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏• ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏ã‡πà‡∏≠‡∏ô -->
        <img id="standardImage" src="https://i.postimg.cc/3xBjR8BG/image.png" style="display:none;" alt="Standard Image">
        <!-- ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà -->
        <table id="step3Table">
            <tr>
                <td class="lang" data-key="fillNForLayer49">‡∏Å‡∏£‡∏≠‡∏Å‡∏Ñ‡πà‡∏≤ N ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ä‡∏±‡πâ‡∏ô‡∏á‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£</td>
                <td><input type="number" id="inputNValue"></td>
            </tr>
            <tr>
                <td class="lang" data-key="errorLabel49">Error</td>
                <td id="errorValue">0</td>
            </tr>
            <tr>
                <td class="lang" data-key="allowedErrorForLayer49">‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏¢‡∏≠‡∏°‡πÉ‡∏´‡πâ‡∏ï‡∏≤‡∏°‡∏ä‡∏±‡πâ‡∏ô‡∏á‡∏≤‡∏ô</td>
                <td id="allowedError">0</td>
            </tr>
            <tr>
                <td class="lang" data-key="checkErrorAllowed49">‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Error ‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏¢‡∏≠‡∏°‡πÉ‡∏´‡πâ‡∏ï‡∏≤‡∏°‡∏ä‡∏±‡πâ‡∏ô‡∏á‡∏≤‡∏ô</td>
                <td id="checkResult"></td>
            </tr>
        </table>
        
  
    </div>
    
     <!--step4-->
    <div id="step4" class="step" style="display: none;">
        <h2 class="lang" data-key="step4Title">Step 4: ‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏õ‡∏£‡∏±‡∏ö‡πÅ‡∏Å‡πâ Depature ‡πÅ‡∏•‡∏∞ Latitude</h2>
        <button class="add-btn lang" data-key="exportToExcel" onclick="exportStepsToExcel()">Export to Excel</button>
        <!-- ‡∏õ‡∏∏‡πà‡∏° ImportFirstData ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô input file ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß -->
        <button onclick="importFirstData1()">Import First Data</button>
        <button onclick="importFirstData2()" class="calcux lang" data-key="calculateButton" style="display: none;">Calculate</button>

        <div class="inputazbutton">
            <input type="text" id="azimuthValue" class="lang-placeholder" data-key="azimuthPlaceholder" placeholder="‡∏õ‡πâ‡∏≠‡∏ô‡∏Ñ‡πà‡∏≤ Azimuth ‡πÅ‡∏£‡∏Å">
            <button class="step-btn lang" data-key="addAzimuth" onclick="addAzimuth()">Add Azimuth</button>
            
            <input type="text" id="EastValue" class="lang-placeholder" data-key="eastPlaceholder" placeholder="Enter East Coordinate">
            <button class="step-btn lang" data-key="addEast" onclick="addCoordinateEast()">Add Coordinate East</button>
            
            <input type="text" id="NorthValue" class="lang-placeholder" data-key="northPlaceholder" placeholder="Enter North Coordinate">
            <button class="step-btn lang" data-key="addNorth" onclick="addCoordinateNorth()">Add Coordinate North</button>
            
          </div>
        <table id="deplatTable">
            <!-- ... your table rows and cells ... -->
        </table>
        <!-- Add input and button for azimuth value -->  
        <button class="standard1a lang" data-key="standard2Button" onclick="toggleNewImage()">‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô2</button>

        <!-- ‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏™‡∏•‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏• -->
        <img id="newImage" src="https://i.postimg.cc/3xBjR8BG/image.png" alt="Image">
        <table id="additionalTable">
            <tr>
              <td>P</td>
              <td id="additionalTableRow1Column2"></td> <!-- ‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡∏î‡πâ‡∏ß‡∏¢ JavaScript -->
            </tr>
            <tr>
              <td>E</td>
              <td id="additionalTableRow2Column2"></td> <!-- ‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡∏î‡πâ‡∏ß‡∏¢ JavaScript -->
            </tr>
            <tr>
              <td>Accuracy Ratio (P/E) = 1 :</td>
              <td id="additionalTableRow3Column2"></td> <!-- ‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡∏î‡πâ‡∏ß‡∏¢ JavaScript -->
            </tr>
          </table>
          
    </div>

     <!--step5-->
    <div id="step5" class="step" style="display: none;">
        <h2 class="lang" data-key="step5Title">Step 5: ‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏ö‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà</h2>
        <button class="add-btn lang" data-key="exportToExcel"onclick="exportStepsToExcel()">Export to Excel</button>
        <div id="map"></div>
        <table id="myTable3"></table>
        </table>
        <table id="distanceTable">
            <tr>
                <td colspan="3">
                    <button class="add-button lang" data-key="calculateDistance" data-action="distance">‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏´‡∏°‡∏∏‡∏î</button>
                </td>
              </tr>
          <tr>
            <th class="lang" data-key="from">‡∏à‡∏≤‡∏Å</th>
            <th class="lang" data-key="to">‡∏ñ‡∏∂‡∏á</th>
            <th class="lang" data-key="distance">‡∏£‡∏∞‡∏¢‡∏∞</th>
          </tr>
          <!-- Table for area calculation -->
          <table id="myTable2">
            <tr>
              <td>
                <button class="add-button lang" data-key="calculateArea" data-action="calculateAreaAndTogglePolygon">‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà</button>
              </td>
            </tr>
            <tr>
              <td>
                <div id="resultDisplay" data-key="areaDisplay"></div>
                <div id="distanceResult"></div>
              </td>
            </tr>
          </table>
    </div>



<script >
        let pins = [];
let surveyTables = [];

function addPin() {
    const pinName = document.getElementById('pinName').value;
    if (pinName && !pins.includes(pinName)) {
        pins.push(pinName);
        document.getElementById('pinName').value = '';
        updateUI();
        calculateInnerAngle();
    }
}

function movePin(index, direction) {
    if (direction === 'up' && index > 0) {
        [pins[index], pins[index - 1]] = [pins[index - 1], pins[index]];
    } else if (direction === 'down' && index < pins.length - 1) {
        [pins[index], pins[index + 1]] = [pins[index + 1], pins[index]];
    }
    updateUI();
}


function handleKeyPress(event) {
    if (event.key === 'Enter') {
        addPin();
    }
}

function deletePin(index) {
    pins.splice(index, 1);
    updateUI();
}
// ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏Ç‡∏≠‡∏á‡∏´‡∏°‡∏∏‡∏î (Pins) ‡∏ï‡∏≤‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
function updatePinTable() {
    const newLang = document.body.getAttribute('data-lang'); // ‡∏î‡∏∂‡∏á‡∏†‡∏≤‡∏©‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
    const table = document.getElementById('pinTable');
    let tableHTML = `<tr><th>${languageData[newLang]['sequence']}</th><th>${languageData[newLang]['pinName']}</th><th>${languageData[newLang]['swapDelete']}</th></tr>`;
    pins.forEach((pin, index) => {
        tableHTML += `<tr><td>${index + 1}</td><td>${pin}</td><td>
            <button class='movepin-btn' onclick='movePin(${index}, "up")'>${languageData[newLang]['up']}</button>
            <button class='movepin-btn' onclick='movePin(${index}, "down")'>${languageData[newLang]['down']}</button>
            <button class='delete-btn' onclick='deletePin(${index})'>${languageData[newLang]['delete']}</button>
            </td></tr>`;
    });
    table.innerHTML = tableHTML;
}


function updateAdditionalTableCalculations() {
  // ‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤‡∏ï‡πà‡∏≤‡∏á‡πÜ
  var totalDistanceValue = document.getElementById("totalDistance").textContent || "0";
  var totalDepartureValue = parseFloat(document.getElementById("totalDeparture").textContent) || 0;
  var totalLatitudeValue = parseFloat(document.getElementById("totalLatitude").textContent) || 0;

  // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡πÅ‡∏ñ‡∏ß‡∏ó‡∏µ‡πà 1 ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ó‡∏µ‡πà 2 ‡∏î‡πâ‡∏ß‡∏¢‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å totalDistance
  document.getElementById("additionalTableRow1Column2").textContent = totalDistanceValue;

  // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ñ‡∏ß‡∏ó‡∏µ‡πà 2 ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ó‡∏µ‡πà 2
  var calculationForRow2Column2 = Math.sqrt(Math.pow(totalDepartureValue, 2) + Math.pow(totalLatitudeValue, 2));
  document.getElementById("additionalTableRow2Column2").textContent = calculationForRow2Column2.toFixed(4);

  // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ñ‡∏ß‡∏ó‡∏µ‡πà 3 ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ó‡∏µ‡πà 2
  var calculationForRow3Column2 = parseFloat(totalDistanceValue) / calculationForRow2Column2;
  document.getElementById("additionalTableRow3Column2").textContent = calculationForRow3Column2.toFixed(4);
}

// ‡∏™‡∏±‡πà‡∏á‡πÉ‡∏´‡πâ JavaScript ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏ß‡πá‡∏ö‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå
document.addEventListener('DOMContentLoaded', function() {
    updateAdditionalTableCalculations();
});

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏õ‡∏•‡∏á‡∏Ñ‡πà‡∏≤ DMS ‡πÑ‡∏õ‡πÄ‡∏õ‡πá‡∏ô‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
function convertDMSToSeconds(dmsValue) {
  var parts = dmsValue.match(/-?\d+\.?\d*/g);
  var degrees = parseInt(parts[0], 10);
  var minutes = parseInt(parts[1], 10);
  var seconds = parseFloat(parts[2]);
  var totalSeconds = degrees * 3600 + minutes * 60 + seconds;
  return degrees < 0 ? -totalSeconds : totalSeconds;
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á
function updateTableCalculations() {
  var errorValue = document.getElementById('errorangle').textContent || "0";
  var errorInSeconds = convertDMSToSeconds(errorValue);
  document.getElementById('errorValue').textContent = errorInSeconds.toFixed(2);
}

document.getElementById('inputNValue').addEventListener('input', updateTableCalculations);
document.addEventListener('DOMContentLoaded', updateTableCalculations);


// ‡πÄ‡∏û‡∏¥‡πà‡∏° Event Listener ‡πÉ‡∏´‡πâ‡∏Å‡∏±‡∏ö input field ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤ N
document.getElementById('inputNValue').addEventListener('input', updateTableCalculations);

// ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ñ‡πà‡∏≤‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏ß‡πá‡∏ö‡πÇ‡∏´‡∏•‡∏î
document.addEventListener('DOMContentLoaded', updateTableCalculations);

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏¢‡∏≠‡∏°‡πÉ‡∏´‡πâ‡∏ï‡∏≤‡∏°‡∏ä‡∏±‡πâ‡∏ô‡∏á‡∏≤‡∏ô‡πÅ‡∏•‡∏∞‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå
function updateAllowedErrorAndCheckResult() {
    var inputNValue = parseFloat(document.getElementById('inputNValue').value) || 0;
    var numberOfPins = pins.length; // ‡∏™‡∏°‡∏°‡∏ï‡∏¥‡∏ß‡πà‡∏≤‡∏Ñ‡∏∏‡∏ì‡∏°‡∏µ array 'pins' ‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÑ‡∏ß‡πâ‡πÅ‡∏•‡πâ‡∏ß
    var errorValue = parseFloat(document.getElementById('errorValue').textContent) || 0;

    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì allowed error ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ä‡∏±‡πâ‡∏ô‡∏á‡∏≤‡∏ô
    var allowedError = inputNValue * Math.sqrt(numberOfPins);
    document.getElementById('allowedError').textContent = allowedError.toFixed(2);

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ error ‡∏ó‡∏µ‡πà‡∏ß‡∏±‡∏î‡πÑ‡∏î‡πâ‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡∏ß‡πà‡∏≤‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏ó‡πà‡∏≤‡∏Å‡∏±‡∏ö allowed error ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    var checkResult = errorValue <= allowedError ? 'OK' : 'NOT OK';
    var checkResultElement = document.getElementById('checkResult');
    checkResultElement.textContent = checkResult;

    // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏µ‡∏ï‡∏≤‡∏°‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç
    if(checkResult === 'OK') {
        checkResultElement.className = 'ok4747';
    } else {
        checkResultElement.className = 'not-ok4747';
    }
}


// ‡πÄ‡∏û‡∏¥‡πà‡∏° Event Listener ‡πÉ‡∏´‡πâ‡∏Å‡∏±‡∏ö input field ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤ N ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì allowed error ‡πÅ‡∏•‡∏∞‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏õ‡πâ‡∏≠‡∏ô‡∏Ñ‡πà‡∏≤
document.getElementById('inputNValue').addEventListener('input', updateAllowedErrorAndCheckResult);

// ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ñ‡πà‡∏≤‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏ß‡πá‡∏ö‡πÇ‡∏´‡∏•‡∏î
document.addEventListener('DOMContentLoaded', updateAllowedErrorAndCheckResult);


function toggleImage() {
    var img = document.getElementById("standardImage");
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ñ‡∏π‡∏Å‡πÅ‡∏™‡∏î‡∏á‡∏≠‡∏¢‡∏π‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà ‡πÅ‡∏•‡∏∞‡∏™‡∏•‡∏±‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•
    if (img.style.display === "none") {
        img.style.display = "block";
    } else {
        img.style.display = "none";
    }
}

function toggleNewImage() {
    var img = document.getElementById("newImage");
    // ‡∏™‡∏•‡∏±‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û
    img.style.display = img.style.display === "none" ? "block" : "none";
}

function importExcelData() {
    var fileInput = document.getElementById('importFile');
    var file = fileInput.files[0];
    if (file) {
        var reader = new FileReader();
        reader.onload = function(e) {
            var data = new Uint8Array(e.target.result);
            var workbook = XLSX.read(data, {type: 'array'});
            var sheetName = workbook.SheetNames.find(name => {
                var sheet = workbook.Sheets[name];
                var cell = sheet['B1'];
                return cell && cell.v === 'Object';
            });
            if (sheetName) {
                var worksheet = workbook.Sheets[sheetName];
                for (var row = 2; ; row += 9) {
                    var address = 'A' + row;
                    var cell = worksheet[address];
                    if (!cell) break;
                    addPinff(cell.v); // ‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô addPin ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏´‡∏°‡∏∏‡∏î
                }
            } else {
                alert("Sheet with B1 as 'Object' not found.");
            }
            importSurveyTable();
            setTimeout(function() {
                importFirstData2(); // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å 1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
            }, 2000); // 

            setTimeout(function() {
                addAzimuth(); // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å 1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
            }, 3000); // 

            setTimeout(function() {
                importFirstData2(); // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å 1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
            }, 13000); // 

            setTimeout(function() {
                addAzimuth(); // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å 1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
            }, 14000); // 

            setTimeout(function() {
                importFirstData2(); // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å 1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
            }, 20000); // 

            setTimeout(function() {
                addAzimuth(); // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å 1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
            }, 21000); // 

            
    
        };
        reader.readAsArrayBuffer(file);
    } else {
        showAlert('pleaseSelectFile');
    }
}

function addPinff(pinName) {
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠‡∏´‡∏°‡∏∏‡∏î ‡πÄ‡∏ä‡πà‡∏ô ‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï UI ‡∏´‡∏£‡∏∑‡∏≠‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏∏‡∏î
    // ‡πÇ‡∏Ñ‡πâ‡∏î‡∏ô‡∏µ‡πâ‡∏Ñ‡∏ß‡∏£‡πÄ‡∏õ‡πá‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏´‡∏°‡∏∏‡∏î‡∏ï‡∏≤‡∏°‡∏õ‡∏Å‡∏ï‡∏¥
    if (!pins.includes(pinName)) {
        pins.push(pinName);
        updateUI(); // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï UI ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏™‡∏î‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏∏‡∏î‡πÉ‡∏´‡∏°‡πà
    }
}

function updateTableDropdown() {
    const tableSelect = document.getElementById('tableSelect');
    tableSelect.innerHTML = '';

    // ‡∏≠‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡∏Ñ‡∏∑‡∏≠‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏°‡∏µ index ‡∏°‡∏≤‡∏Å‡∏™‡∏∏‡∏î (‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏õ‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î) ‡πÉ‡∏´‡πâ‡πÅ‡∏™‡∏î‡∏á‡∏Å‡πà‡∏≠‡∏ô‡πÉ‡∏ô dropdown
    for (let i = surveyTables.length - 1; i >= 0; i--) {
        const option = document.createElement('option');
        option.value = i;
        option.textContent = `Station: ${surveyTables[i].station}`;
        tableSelect.appendChild(option);
    }
}


function deleteTableByStation() {
    const selectedStationIndex = document.getElementById('tableSelect').value;
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å station ‡∏à‡∏£‡∏¥‡∏á
    if (selectedStationIndex !== '') {
        const tableElement = document.getElementById(`surveyTable-${selectedStationIndex}`);
        if (tableElement) {
            tableElement.remove(); // ‡∏•‡∏ö‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
        }
        surveyTables.splice(selectedStationIndex, 1); // ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏à‡∏≤‡∏Å array
        updateTableDropdown(); // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï dropdown
    }
}


function setupDeleteButton() {
    const deleteButton = document.getElementById('deleteButton');
    deleteButton.addEventListener('click', deleteTableByStation);
}


// ‡πÅ‡∏•‡∏∞‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏ß‡πá‡∏ö‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏™‡∏£‡πá‡∏à
document.addEventListener('DOMContentLoaded', setupDeleteButton);


// ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ event listeners ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏ß‡πá‡∏ö‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏™‡∏£‡πá‡∏à
document.addEventListener('DOMContentLoaded', function() {
    // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï dropdown ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÇ‡∏´‡∏•‡∏î‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏ß‡πá‡∏ö
    updateTableDropdown();
    // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ event listener ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏∏‡πà‡∏°‡∏•‡∏ö
    setupDeleteButton();
});


// Object ‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏†‡∏≤‡∏©‡∏≤
const languageData = {
  'en': {
    'step1Title': 'Step 1: Add Pin list data',
    'changeLanguageButton': 'Language : English',
    'step1': 'Step 1',
  'step2': 'Step 2',
  'step3': 'Step 3',
  'step4': 'Step 4',
  'step5': 'Step 5',
  'pinNamePlaceholder': 'Pin Name',
  'addButton': 'Add',
  'exportPinsButton': 'Export to Excel',
  'sequence': 'Sequence',
  'pinName': 'Pin Name',
  'swapDelete': 'Swap / Delete',
  'up': 'Up ‚¨ÜÔ∏è',
  'down': 'Down ‚¨áÔ∏è',
  'delete': 'Delete ‚ùå',
  'importData': 'Import Data',
  'step2Title': 'Step 2: Create Internal Angle Measurement Table',
  'stationCamera': 'Station:',
  'object1': 'Object 1:',
  'object2': 'Object 2:',
  'createTable': 'Create Table',
  'exportStepsExcel': 'Export to Excel',
  'deleteTable': 'Delete',
  'step3Title': 'Step 3: Internal Angle Survey Table',
  'step4Title': 'Step 4: Adjusting Departure and Latitude Table',
  'azimuthPlaceholder': 'Enter initial Azimuth (¬∞)',
  'addAzimuth': 'Add Azimuth ',
  'eastPlaceholder': 'Enter East Coordinate  (meter)',
  'addEast': 'Add Coordinate East',
  'northPlaceholder': 'Enter North Coordinate  (meter)',
  'addNorth': 'Add Coordinate North',
  'step5Title': 'Step 5: Map Coordinates',
  'exportToExcel': 'Export to Excel',
  'calculateDistance': 'Calculate Distance Between Pins',
  'from': 'From',
  'to': 'To',
  'calculateArea': 'Calculate Area',
  'distance': 'Distance',
  'pinCoordinates': 'Pin Coordinates',
  'exportToExcel': 'Export to Excel',
  'pleaseSelectFile': 'Please select a file.',
  'calculateButton': 'Calculate',
  'errorPinInvalid': 'The operation cannot continue because the pin is incorrect or already in use.',
  'errorPinInvalid': 'The operation cannot continue because the pin is incorrect or already in use.',
  'errorAzimuthValue': 'Please enter a valid azimuth value between 0 and 359.99999.',
  'errorEastCoordinate': 'Please enter a valid East coordinate.',
  'errorNorthCoordinate': 'Please enter a valid North coordinate.',
  'areaCalculationWarning': 'Please add at least 3 markers for area calculation.',
  'areaResultPrefix': 'Area:',
  'areaUnit': 'square meters',
  'meter': 'meter',
  'longitudeOutOfRange': 'The provided longitude is not in the specified range (96 to 108).',
  'minimumTwoCoordinatesAlert': 'Please add at least 2 coordinates to calculate distance.',
  'noPinData': 'No pin data available',
    'station': 'Station',
    'ha': 'Horizontal Angle (¬∞ \' ")',
    'correction2': 'Correction (¬∞ \' ")',
    'adjustedHA': 'Adjusted Horizontal Angle (¬∞ \' ")',
    'station': 'Station',
    'adjustedHA': 'Adjusted Horizontal Angle (¬∞)',
    'azimuth': 'Azimuth (¬∞)',
    'distanceMeter': 'Distance (meter)',
    'departure': 'Departure (meter)',
    'latitude': 'Latitude (meter)',
    'correction': 'Correction',
    'balanced': 'Balanced',
    'east': 'Easting (meter)',
    'north': 'Northing (meter)',
    'pinCoordinates47': 'Pin Coordinates',
    'east47': 'Easting (meter)',
    'north47': 'Northing (meter)',
    'lon47': 'Longitude ( ¬∞ )',
    'lat47': 'Latitude ( ¬∞ )',
    'station48': 'Station',
    'object48': 'Object',
    'horizontalAngleReading48': 'Horizontal Angle Reading (¬∞ \' ")',
    'horizontalAngle48': 'Horizontal Angle (¬∞ \' ")',
    'averageHorizontalAngle48': 'Average Horizontal Angle (¬∞ \' ")',
    'horizontalDistanceMeter48': 'Horizontal Distance (meter)',
    'manualButton48': 'Manualüìñ',
    'fillNForLayer49': 'Enter Factor Value by Order Class (")',
    'errorLabel49': 'Error (")',
    'allowedErrorForLayer49': 'Allowed Error  (")',
    'checkErrorAllowed49': 'Check',
    'standard2Button': 'Standard',
  'standardButton': 'Standard',
  },


  'th': {
    'step1Title': '‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 1: ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠‡∏´‡∏°‡∏∏‡∏î',
    'changeLanguageButton': '‡∏†‡∏≤‡∏©‡∏≤ : ‡πÑ‡∏ó‡∏¢',
    'step1': '‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 1',
  'step2': '‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 2',
  'step3': '‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 3',
  'step4': '‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 4',
  'step5': '‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 5',
  'pinNamePlaceholder': '‡∏ä‡∏∑‡πà‡∏≠‡∏´‡∏°‡∏∏‡∏î',
  'addButton': '‡πÄ‡∏û‡∏¥‡πà‡∏°',
  'exportPinsButton': '‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡πÄ‡∏õ‡πá‡∏ô Excel',
  'sequence': '‡∏•‡∏≥‡∏î‡∏±‡∏ö',
  'pinName': '‡∏ä‡∏∑‡πà‡∏≠‡∏´‡∏°‡∏∏‡∏î',
  'swapDelete': '‡∏™‡∏•‡∏±‡∏ö‡∏•‡∏≥‡∏î‡∏±‡∏ö / ‡∏•‡∏ö',
  'up': '‡∏Ç‡∏∂‡πâ‡∏ô ‚¨ÜÔ∏è',
  'down': '‡∏•‡∏á ‚¨áÔ∏è',
  'delete': '‡∏•‡∏ö ‚ùå',
  'importData': '‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•',
  'step2Title': '‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 2: ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏£‡∏±‡∏á‡∏ß‡∏±‡∏î‡∏°‡∏∏‡∏°‡∏†‡∏≤‡∏¢‡πÉ‡∏ô',
  'stationCamera': '‡∏´‡∏°‡∏∏‡∏î‡∏ï‡∏±‡πâ‡∏á‡∏Å‡∏•‡πâ‡∏≠‡∏á:',
  'object1': '‡∏´‡∏°‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏™‡πà‡∏≠‡∏á1:',
  'object2': '‡∏´‡∏°‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏™‡πà‡∏≠‡∏á2:',
  'createTable': '‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ï‡∏≤‡∏£‡∏≤‡∏á',
  'exportStepsExcel': '‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡πÄ‡∏õ‡πá‡∏ô Excel',
  'deleteTable': '‡∏•‡∏ö',
  'step3Title': '‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 3: ‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏£‡∏±‡∏á‡∏ß‡∏±‡∏î‡∏°‡∏∏‡∏°‡∏†‡∏≤‡∏¢‡πÉ‡∏ô',
   'step4Title': '‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 4: ‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏õ‡∏£‡∏±‡∏ö‡πÅ‡∏Å‡πâ Depature ‡πÅ‡∏•‡∏∞ Latitude',
  'azimuthPlaceholder': '‡∏õ‡πâ‡∏≠‡∏ô‡∏Ñ‡πà‡∏≤‡πÅ‡∏≠‡∏ã‡∏¥‡∏°‡∏±‡∏ó‡πÅ‡∏£‡∏Å (¬∞)',
  'addAzimuth': '‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÅ‡∏≠‡∏ã‡∏¥‡∏°‡∏±‡∏ó',
  'eastPlaceholder': '‡∏õ‡πâ‡∏≠‡∏ô‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏ï‡∏∞‡∏ß‡∏±‡∏ô‡∏≠‡∏≠‡∏Å (‡πÄ‡∏°‡∏ï‡∏£)',
  'addEast': '‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏ï‡∏∞‡∏ß‡∏±‡∏ô‡∏≠‡∏≠‡∏Å‡πÅ‡∏£‡∏Å',
  'northPlaceholder': '‡∏õ‡πâ‡∏≠‡∏ô‡∏û‡∏¥‡∏Å‡∏±‡∏î‡πÄ‡∏´‡∏ô‡∏∑‡∏≠ (‡πÄ‡∏°‡∏ï‡∏£)',
  'addNorth': '‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏û‡∏¥‡∏Å‡∏±‡∏î‡πÄ‡∏´‡∏ô‡∏∑‡∏≠',
  'step5Title': '‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 5: ‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏ö‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà',
  'exportToExcel': '‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡πÄ‡∏õ‡πá‡∏ô Excel',
  'calculateDistance': '‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏´‡∏°‡∏∏‡∏î',
  'from': '‡∏à‡∏≤‡∏Å',
  'to': '‡∏ñ‡∏∂‡∏á',
  'calculateArea': '‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà',
  'distance': '‡∏£‡∏∞‡∏¢‡∏∞',
  'pinCoordinates': '‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏´‡∏°‡∏∏‡∏î',
  'exportToExcel': '‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡πÄ‡∏õ‡πá‡∏ô Excel',
  'pleaseSelectFile': '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå.',
  'calculateButton': '‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì',
  'errorPinInvalid': '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡πà‡∏≠‡πÑ‡∏î‡πâ‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏à‡∏≤‡∏Å‡∏´‡∏°‡∏∏‡∏î‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏£‡∏∑‡∏≠‡∏ñ‡∏π‡∏Å‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÅ‡∏•‡πâ‡∏ß',
  'errorPinInvalid': '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡πà‡∏≠‡πÑ‡∏î‡πâ‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏à‡∏≤‡∏Å‡∏´‡∏°‡∏∏‡∏î‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏£‡∏∑‡∏≠‡∏ñ‡∏π‡∏Å‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÅ‡∏•‡πâ‡∏ß',
  'errorAzimuthValue': '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÉ‡∏™‡πà‡∏Ñ‡πà‡∏≤ azimuth ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á 0 ‡∏ñ‡∏∂‡∏á 359.99999',
  'errorEastCoordinate': '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÉ‡∏™‡πà‡∏Ñ‡πà‡∏≤‡∏û‡∏¥‡∏Å‡∏±‡∏î East ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á',
  'errorNorthCoordinate': '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÉ‡∏™‡πà‡∏Ñ‡πà‡∏≤‡∏û‡∏¥‡∏Å‡∏±‡∏î North ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á',
  'areaCalculationWarning': '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏´‡∏°‡∏∏‡∏î‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 3 ‡∏û‡∏¥‡∏Å‡∏±‡∏î ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà',
  'areaResultPrefix': '‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà:',
  'areaUnit': '‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÄ‡∏°‡∏ï‡∏£',
  'meter': '‡πÄ‡∏°‡∏ï‡∏£',
  'longitudeOutOfRange': '‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏•‡∏≠‡∏á‡∏à‡∏¥‡∏à‡∏π‡∏î‡∏ó‡∏µ‡πà‡πÉ‡∏´‡πâ‡∏°‡∏≤‡πÑ‡∏°‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏Ç‡∏≠‡∏ö‡πÄ‡∏Ç‡∏ï‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î (96 ‡∏ñ‡∏∂‡∏á 108).',
  'minimumTwoCoordinatesAlert': '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏´‡∏°‡∏∏‡∏ô‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 2 ‡∏û‡∏¥‡∏Å‡∏±‡∏î ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á',
  'noPinData': '‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏°‡∏∏‡∏î',
    'station': '‡∏´‡∏°‡∏∏‡∏î',
    'ha': '‡∏°‡∏∏‡∏°‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏á‡∏ß‡∏±‡∏î (¬∞ \' ")',
    'correction2': '‡∏Ñ‡πà‡∏≤‡∏õ‡∏£‡∏±‡∏ö‡πÅ‡∏Å‡πâ (¬∞ \' ")',
    'adjustedHA': '‡∏°‡∏∏‡∏°‡∏£‡∏±‡∏á‡∏ß‡∏±‡∏î‡∏ó‡∏µ‡πà‡∏õ‡∏£‡∏±‡∏ö‡πÅ‡∏Å‡πâ (¬∞ \' ")',
    'station': '‡∏´‡∏°‡∏∏‡∏î',
    'adjustedHA': '‡∏°‡∏∏‡∏°‡∏£‡∏±‡∏á‡∏ß‡∏±‡∏î‡∏ó‡∏µ‡πà‡∏õ‡∏£‡∏±‡∏ö‡πÅ‡∏Å‡πâ (¬∞)',
    'azimuth': '‡πÅ‡∏≠‡∏ã‡∏¥‡∏°‡∏±‡∏ó (¬∞)',
    'distanceMeter': '‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á (‡πÄ‡∏°‡∏ï‡∏£)',
    'departure': '‡∏Ñ‡πà‡∏≤‡∏£‡∏∞‡∏¢‡∏∞‡∏ï‡∏∞‡∏ß‡∏±‡∏ô‡∏≠‡∏≠‡∏Å (‡πÄ‡∏°‡∏ï‡∏£)',
    'latitude': '‡∏Ñ‡πà‡∏≤‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏´‡∏ô‡∏∑‡∏≠ (‡πÄ‡∏°‡∏ï‡∏£)',
    'correction': '‡∏Ñ‡πà‡∏≤‡∏õ‡∏£‡∏±‡∏ö‡πÅ‡∏Å‡πâ',
    'balanced': '‡∏Ñ‡πà‡∏≤‡∏õ‡∏£‡∏±‡∏ö‡∏™‡∏°‡∏î‡∏∏‡∏•',
    'east': '‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏ï‡∏∞‡∏ß‡∏±‡∏ô‡∏≠‡∏≠‡∏Å (‡πÄ‡∏°‡∏ï‡∏£)',
    'north': '‡∏û‡∏¥‡∏Å‡∏±‡∏î‡πÄ‡∏´‡∏ô‡∏∑‡∏≠ (‡πÄ‡∏°‡∏ï‡∏£)',
    'pinCoordinates47': '‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏´‡∏°‡∏∏‡∏î',
    'east47': '‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏ï‡∏∞‡∏ß‡∏±‡∏ô‡∏≠‡∏≠‡∏Å (‡πÄ‡∏°‡∏ï‡∏£)',
    'north47': '‡∏û‡∏¥‡∏Å‡∏±‡∏î‡πÄ‡∏´‡∏ô‡∏∑‡∏≠ (‡πÄ‡∏°‡∏ï‡∏£)',
    'lon47': '‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏•‡∏≠‡∏á‡∏à‡∏¥‡∏à‡∏π‡∏î ( ¬∞ )',
    'lat47': '‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏•‡∏∞‡∏ï‡∏¥‡∏à‡∏π‡∏î ( ¬∞ )',
    'station48': '‡∏´‡∏°‡∏∏‡∏î‡∏ï‡∏±‡πâ‡∏á‡∏Å‡∏•‡πâ‡∏≠‡∏á',
    'object48': '‡∏´‡∏°‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏™‡πà‡∏≠‡∏á',
    'horizontalAngleReading48': '‡∏Ñ‡πà‡∏≤‡∏°‡∏∏‡∏°‡∏£‡∏≤‡∏ö‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏á‡∏ß‡∏±‡∏î (¬∞ \' ")',
    'horizontalAngle48': '‡∏Ñ‡πà‡∏≤‡∏°‡∏∏‡∏°‡∏£‡∏≤‡∏ö (¬∞ \' ")',
    'averageHorizontalAngle48': '‡∏Ñ‡πà‡∏≤‡∏°‡∏∏‡∏°‡∏£‡∏≤‡∏ö‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢ (¬∞ \' ")',
    'horizontalDistanceMeter48': '‡∏Ñ‡πà‡∏≤‡∏£‡∏∞‡∏¢‡∏∞‡πÅ‡∏ô‡∏ß‡∏£‡∏≤‡∏ö (‡πÄ‡∏°‡∏ï‡∏£)',
    'manualButton48': '‡∏Ñ‡∏π‡πà‡∏°‡∏∑‡∏≠üìñ',
    'fillNForLayer49': '‡∏Å‡∏£‡∏≠‡∏Å‡∏Ñ‡πà‡∏≤‡∏õ‡∏£‡∏±‡∏ö‡πÅ‡∏Å‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ä‡∏±‡πâ‡∏ô‡∏á‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ (")',
    'errorLabel49': '‡∏Ñ‡πà‡∏≤‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏ó‡∏≤‡∏á‡∏°‡∏∏‡∏°  (")',
    'allowedErrorForLayer49': '‡∏Ñ‡πà‡∏≤‡∏ï‡∏≤‡∏°‡∏Ç‡πâ‡∏≠‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏ä‡∏±‡πâ‡∏ô‡∏á‡∏≤‡∏ô (")',
    'checkErrorAllowed49': '‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö',
    'standard2Button': '‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô',
  'standardButton': '‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô',
  }
};

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏†‡∏≤‡∏©‡∏≤
function changeLanguage() {
  const newLang = document.body.getAttribute('data-lang') === 'th' ? 'en' : 'th';
  document.body.setAttribute('data-lang', newLang);

  document.querySelectorAll('.lang').forEach(element => {
    const key = element.getAttribute('data-key');
    element.textContent = languageData[newLang][key];
  });

  document.querySelectorAll('.lang-placeholder').forEach(element => {
    const key = element.getAttribute('data-key');
    element.placeholder = languageData[newLang][key];
  });
  document.querySelectorAll('.lang-unit').forEach(element => {
  element.textContent = languageData[newLang]['meter'];
});


  // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ç‡∏≠‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà
  const resultDisplay = document.getElementById("resultDisplay");
  const resultKey = resultDisplay.getAttribute('data-key');
  if (resultKey === 'areaResult' && window.latestAreaCalculationResult !== undefined) {
    resultDisplay.textContent = `${languageData[newLang]['areaResultPrefix']} ${window.latestAreaCalculationResult} ${languageData[newLang]['areaUnit']}`;
  } else {
    resultDisplay.textContent = languageData[newLang][resultKey];
  }

  updatePinTable(); // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏ó‡∏±‡∏ô‡∏ó‡∏µ‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏†‡∏≤‡∏©‡∏≤
}


// ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏†‡∏≤‡∏©‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏Ç‡∏≠‡∏á‡πÄ‡∏ß‡πá‡∏ö
document.body.setAttribute('data-lang', 'en'); // ‡∏†‡∏≤‡∏©‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏ß‡πá‡∏ö‡πÇ‡∏´‡∏•‡∏î

document.body.setAttribute('data-lang', 'en'); // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏†‡∏≤‡∏©‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
changeLanguage(); // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÉ‡∏´‡πâ‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏†‡∏≤‡∏©‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
// ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏ß‡πá‡∏ö‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô, ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡∏≤‡∏°‡∏†‡∏≤‡∏©‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
window.onload = function() {
  changeLanguage(); // ‡∏´‡∏£‡∏∑‡∏≠‡∏≠‡∏≤‡∏à‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ changeLanguage() ‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏™‡∏•‡∏±‡∏ö‡∏†‡∏≤‡∏©‡∏≤
};

function showAlert(key) {
  const lang = document.body.getAttribute('data-lang');
  alert(languageData[lang][key]);
}

function showAlert(key) {
  const lang = document.body.getAttribute('data-lang');
  alert(languageData[lang][key]);
}

document.addEventListener('DOMContentLoaded', function() {
  document.querySelectorAll('[data-action]').forEach(button => {
    button.addEventListener('click', function() {
      const actionName = button.getAttribute('data-action');
      window[actionName]();
    });
  });

  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏†‡∏≤‡∏©‡∏≤‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏™‡∏£‡πá‡∏à
  changeLanguage();
});

function showAlert(key) {
  const language = document.body.getAttribute('data-lang');
  const message = languageData[language][key];
  alert(message);
}

function goToLink() {
        window.location.href = "https://docs.google.com/document/d/1og7Bj06gleO_5vTLY_GMaJLibXs3m2Z_tiwb-L08LjY/edit?usp=sharing";
    }

// ‡∏Ñ‡∏∏‡∏ì‡∏≠‡∏≤‡∏à‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡πÇ‡∏Ñ‡πâ‡∏î‡∏ô‡∏µ‡πâ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ event listener ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏∏‡πà‡∏°
document.querySelectorAll('.step-btna').forEach(button => {
  button.addEventListener('click', function() {
    // Remove active class from all buttons
    document.querySelectorAll('.step-btna.active').forEach(activeButton => {
      activeButton.classList.remove('active');
    });
    // Add active class to the clicked button
    this.classList.add('active');
  });
});
    // ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏õ‡∏∏‡πà‡∏°‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ ID ‡∏Ç‡∏≠‡∏á‡∏õ‡∏∏‡πà‡∏°
    var button = document.getElementById('myButton');

    // ‡πÄ‡∏û‡∏¥‡πà‡∏° Event Listener ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ó‡∏µ‡πà‡∏õ‡∏∏‡πà‡∏°
    button.addEventListener('click', function() {
        // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î URL ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡πâ‡∏•‡∏¥‡∏á‡∏Ñ‡πå‡πÑ‡∏õ
        var link = 'https://drive.google.com/file/d/1LSxLdCIqJ84FWlo8QZLp7Ec4tVgb3Tel/view?usp=sharing'; // ‡πÅ‡∏Å‡πâ‡∏ï‡∏≤‡∏° URL ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£

        // ‡πÄ‡∏õ‡∏¥‡∏î‡∏•‡∏¥‡∏á‡∏Ñ‡πå‡πÉ‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà
        window.open(link, '_blank');
        
        // ‡∏´‡∏£‡∏∑‡∏≠‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô URL ‡πÉ‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡πá‡πÉ‡∏ä‡πâ
        // window.location.href = link;
    });
// ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÉ‡∏ô dropdown menus ‡∏ï‡∏≤‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏°‡∏∏‡∏î (Pins) ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà
function updateDropdowns() {
    ['stationSelect', 'object1Select', 'object2Select'].forEach(selectId => {
        const select = document.getElementById(selectId);
        let optionsHTML = pins.map(pin => `<option value="${pin}">${pin}</option>`);
        select.innerHTML = optionsHTML.join('');
    });
}

function createSurveyTable() {
    const station = document.getElementById('stationSelect').value;
    const object1 = document.getElementById('object1Select').value;
    const object2 = document.getElementById('object2Select').value;

    if (station === object1 || station === object2 || object1 === object2 || surveyTables.some(table => table.station === station)) {
        showAlert('errorPinInvalid');
        return;
    }
    surveyTables.push({ station, object1, object2, data: [] });
    displaySurveyTables();
    populateTable(); 
    displayAverageHDTable();
    updateSwappedAverageHDTable();
    createFinalHDTable();
    updateMeasurementTable(station); // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 3
    updateTableDropdown();
}


function updateMeasurementTable(selectedStation) {
    // ‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÉ‡∏ô‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 3 ‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ä‡∏∑‡πà‡∏≠‡∏™‡∏ñ‡∏≤‡∏ô‡∏µ
    const measurementTable = document.getElementById('measurementTable');
    if (measurementTable) {
        // ‡∏´‡∏≤‡πÅ‡∏ñ‡∏ß‡∏ó‡∏µ‡πà‡∏°‡∏µ cell ‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
        const rows = measurementTable.rows;
        for (let i = 0; i < rows.length; i++) {
            // ‡∏™‡∏°‡∏°‡∏ï‡∏¥‡∏ß‡πà‡∏≤ cell ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏ä‡∏∑‡πà‡∏≠‡∏™‡∏ñ‡∏≤‡∏ô‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô column ‡πÅ‡∏£‡∏Å (index 0)
            const stationCell = rows[i].cells[0];
            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ cell ‡∏ô‡∏µ‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡∏≠‡∏á‡πÅ‡∏ñ‡∏ß‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏ä‡∏∑‡πà‡∏≠‡∏™‡∏ñ‡∏≤‡∏ô‡∏µ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
            if (stationCell && stationCell.textContent.match(/^[ABCD]$/)) {
                stationCell.textContent = selectedStation; // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ä‡∏∑‡πà‡∏≠‡∏™‡∏ñ‡∏≤‡∏ô‡∏µ
                break; // ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å loop ‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÅ‡∏ñ‡∏ß‡πÅ‡∏£‡∏Å
            }
        }
    }
}

function importSurveyTable() {
    var fileInput = document.getElementById('importFile');
    var file = fileInput.files[0];
    if (file) {
        var reader = new FileReader();
        reader.onload = function(e) {
            var data = new Uint8Array(e.target.result);
            var workbook = XLSX.read(data, {type: 'array'});
            var sheetName = workbook.SheetNames.find(name => workbook.Sheets[name]['B1'] && workbook.Sheets[name]['B1'].v === 'Object');
            if (sheetName) {
                var worksheet = workbook.Sheets[sheetName];
                var row = 2; // Start from the second row
                while (worksheet['A' + row]) {
                    var station = worksheet['A' + row].v;
                    var object1 = worksheet['B' + row].v;
                    var object2 = worksheet['B' + (row + 1)].v;
                    // Call createSurveyTable function for each set of station, object1, and object2
                    createSurveyTableAutomatically(station, object1, object2);
                    row += 9; // Jump to the next set of data
                }
            } else {
                alert("Sheet with B1 as 'Object' not found.");
            }
            importSurveyTableHAHD();
        };
        reader.readAsArrayBuffer(file);
    } else {
        showAlert('pleaseSelectFile');
    }
}

function createSurveyTableAutomatically(station, object1, object2) {
    if (station === object1 || station === object2 || object1 === object2 || surveyTables.some(table => table.station === station)) {
        console.log('Invalid data or station already used.');
        return;
    }
    surveyTables.push({ station, object1, object2, data: [] });
    displaySurveyTables();
    populateTable(); 
    displayAverageHDTable();
    updateSwappedAverageHDTable();
    createFinalHDTable();
    updateMeasurementTable(station);
    updateTableDropdown();
    updateTableDropdown();
}

function importSurveyTableHAHD() {
    const fileInput = document.getElementById('importFile');
    const file = fileInput.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = function(e) {
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, {type: 'array'});

            // ‡∏´‡∏≤‡πÅ‡∏ú‡πà‡∏ô‡∏á‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏°‡∏µ "Object" ‡∏ó‡∏µ‡πà‡πÄ‡∏ã‡∏•‡∏•‡πå B1 ‡πÅ‡∏•‡∏∞‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å‡πÅ‡∏ú‡πà‡∏ô‡∏á‡∏≤‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏ô‡∏µ‡πâ
            const targetSheetNames = workbook.SheetNames.filter(name => workbook.Sheets[name]['B1'] && workbook.Sheets[name]['B1'].v === 'Object');

            // ‡∏ß‡∏ô‡∏•‡∏π‡∏õ‡∏ú‡πà‡∏≤‡∏ô‡πÅ‡∏ú‡πà‡∏ô‡∏á‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏û‡∏ö
            targetSheetNames.forEach(targetSheetName => {
                const worksheet = workbook.Sheets[targetSheetName];
                let row = 2; // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å A2

                // ‡∏ß‡∏ô‡∏•‡∏π‡∏õ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å‡πÅ‡∏ñ‡∏ß‡πÉ‡∏ô‡πÅ‡∏ú‡πà‡∏ô‡∏á‡∏≤‡∏ô
                while (worksheet[`A${row}`]) {
                    const stationName = worksheet[`A${row}`].v;
                    const haReadings = [];
                    const hdValues = [];

                    // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• HA reading ‡πÅ‡∏•‡∏∞ HD ‡∏à‡∏≤‡∏Å‡πÅ‡∏ú‡πà‡∏ô‡∏á‡∏≤‡∏ô
                    for (let i = 0; i < 8; i++) {
                        const haCellRef = `C${row + i}`;
                        const hdCellRef = `F${row + i}`;
                        const haReading = worksheet[haCellRef] ? parseHAReading(worksheet[haCellRef].v) : null;
                        const hdValue = worksheet[hdCellRef] ? worksheet[hdCellRef].v : null;

                        if (haReading) haReadings.push(haReading);
                        if (hdValue !== null) hdValues.push(hdValue);
                    }

                    // ‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Ç‡πâ‡∏≠‡∏á
                    updateTablesWithData({ stationName, haReadings, hdValues });

                    row += 9; // ‡πÑ‡∏õ‡∏¢‡∏±‡∏á station ‡∏ñ‡∏±‡∏î‡πÑ‡∏õ
                }
            });
        };
        reader.readAsArrayBuffer(file);
    } else {
        showAlert('pleaseSelectFile');
    }
}

function updateTablesWithData({ stationName, haReadings, hdValues }) {
    // ‡∏ß‡∏ô‡∏•‡∏π‡∏õ‡∏ú‡πà‡∏≤‡∏ô‡∏ó‡∏∏‡∏Å `surveyTables` ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏≤‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏°‡∏µ 'station' ‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö `stationName`
    surveyTables.forEach((table, index) => {
        if (table.station === stationName) {
            // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï HA readings ‡πÅ‡∏•‡∏∞ HD values ‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ô
            haReadings.forEach((reading, readingIndex) => {
                // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï HA reading
                const degreeInput = document.querySelector(`#degrees-${index}-${readingIndex}`);
                const minuteInput = document.querySelector(`#minutes-${index}-${readingIndex}`);
                const secondInput = document.querySelector(`#seconds-${index}-${readingIndex}`);
                degreeInput.value = reading.degrees;
                minuteInput.value = reading.minutes;
                secondInput.value = reading.seconds;

                // Trigger the change event manually to invoke calculation
                [degreeInput, minuteInput, secondInput].forEach(input => {
                    const event = new Event('change', {
                        'bubbles': true,
                        'cancelable': true
                    });
                    input.dispatchEvent(event);
                });
            });

            hdValues.forEach((value, valueIndex) => {
                // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï HD value
                const hdInput = document.querySelector(`#hd-value-${index}-${valueIndex}`);
                hdInput.value = value;

                // Trigger the change event for HD input to invoke HD related calculations
                const event = new Event('change', {
                    'bubbles': true,
                    'cancelable': true
                });
                hdInput.dispatchEvent(event);

                // Assuming `handleHDInputChange` is the function to be called for each HD input change
                handleHDInputChange(stationName, value, valueIndex, value);
            });

            // Assuming these functions exist and need to be called after HD values are updated
            populateTable();
            displayAverageHDTable();
            updateSwappedAverageHDTable();
            createFinalHDTable();
        }
    });
}

function parseHAReading(reading) {
    var [degrees, minutes, seconds] = reading.split(/[¬∞'"]/).map(num => parseInt(num, 10));
    return { degrees, minutes, seconds };
}


function importFirstData1() {
    var fileInput = document.getElementById('importFile');
    var file = fileInput.files[0];
    if (file) {
        var reader = new FileReader();
        reader.onload = function(e) {
            var data = new Uint8Array(e.target.result);
            var workbook = XLSX.read(data, {type: 'array'});
            var sheetName = workbook.SheetNames.find(name => workbook.Sheets[name]['C1'] && workbook.Sheets[name]['C1'].v === 'Azimuth');
            
            if (sheetName) {
                var worksheet = workbook.Sheets[sheetName];
                var stationName = worksheet['A2'] ? worksheet['A2'].v : null;
                var azimuthValue = worksheet['C3'] ? worksheet['C3'].v : null;
                var eastValue = worksheet['K3'] ? worksheet['K3'].v : null;
                var northValue = worksheet['L3'] ? worksheet['L3'].v : null;

                if(stationName && azimuthValue !== null && eastValue !== null && northValue !== null) {
                    // Update values in the table
                    document.querySelector(`.azimuthCell[data-station="${stationName}"]`).textContent = azimuthValue;
                    document.getElementById(`coordinatesEast-${stationName}`).textContent = eastValue;
                    document.getElementById(`coordinatesNorth-${stationName}`).textContent = northValue;
                    
                    // Calculate Departure and Latitude for the pin
                    calculateDepAndLatForPin(stationName);
                    
                    // Call calculateDepAndLatForPin() with the appropriate pin variable
                    pins.forEach(pin => {
                        calculateDepAndLatForPin(pin);
                    });

                    // Calculate Azimuth
                    calculateAzimuth();
                } else {
                    alert("‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡πÑ‡∏ü‡∏•‡πå Excel ‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á");
                }
            } else {
                alert("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ä‡∏µ‡∏ó‡∏ó‡∏µ‡πà‡∏°‡∏µ 'Azimuth' ‡πÉ‡∏ô‡πÄ‡∏ã‡∏• C1");
            }
        };
        reader.readAsArrayBuffer(file);
    } else {
        alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏Å‡πà‡∏≠‡∏ô");
    }
}

function importFirstData2() {
    var fileInput = document.getElementById('importFile');
    var file = fileInput.files[0];
    if (file) {
        var reader = new FileReader();
        reader.onload = function(e) {
            var data = new Uint8Array(e.target.result);
            var workbook = XLSX.read(data, {type: 'array'});
            var sheetName = workbook.SheetNames.find(name => workbook.Sheets[name]['C1'] && workbook.Sheets[name]['C1'].v === 'Azimuth');
            
            if (sheetName) {
                var worksheet = workbook.Sheets[sheetName];
                var stationName = worksheet['A2'] ? worksheet['A2'].v : null;
                var azimuthValue = worksheet['C3'] ? worksheet['C3'].v : null;
                var eastValue = worksheet['K3'] ? worksheet['K3'].v : null;
                var northValue = worksheet['L3'] ? worksheet['L3'].v : null;

                if(stationName && azimuthValue !== null && eastValue !== null && northValue !== null) {
                    // Update values in the table
                    document.getElementById('azimuthValue').value = azimuthValue;

                    document.getElementById(`coordinatesEast-${stationName}`).textContent = eastValue;
                    document.getElementById(`coordinatesNorth-${stationName}`).textContent = northValue;
                    
                    // Calculate Departure and Latitude for the pin
                    calculateDepAndLatForPin(stationName);
                    
                    // Call calculateDepAndLatForPin() with the appropriate pin variable
                    pins.forEach(pin => {
                        calculateDepAndLatForPin(pin);
                    });

                    // Calculate Azimuth
                    calculateAzimuth();
                } else {
                    alert("‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡πÑ‡∏ü‡∏•‡πå Excel ‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á");
                }
            } else {
                alert("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ä‡∏µ‡∏ó‡∏ó‡∏µ‡πà‡∏°‡∏µ 'Azimuth' ‡πÉ‡∏ô‡πÄ‡∏ã‡∏• C1");
            }
        };
        reader.readAsArrayBuffer(file);
    } else {
        alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏Å‡πà‡∏≠‡∏ô");
    }
   
}

function displaySurveyTables() {
    const surveyTablesDiv = document.getElementById('surveyTables');
    const newTableHTML = createTableHTML(surveyTables[surveyTables.length - 1], surveyTables.length - 1);
    surveyTablesDiv.insertAdjacentHTML('beforeend', newTableHTML);
    setupInputListenersForTable(surveyTables.length - 1);
    populateTable(); 
}

function createTableHTML(table, index) {
    let rowsHTML = '';
    for (let i = 0; i < 8; i++) {
        let objectToShow = (i % 4 === 0 || i % 4 === 3) ? table.object1 : table.object2;
        rowsHTML += `
            <tr>
                <td>${i % 2 === 0 ? table.station : ''}</td>
                <td>${objectToShow}</td>
                <td class="input yellow">
                    <input type="number" class="degrees" id="degrees-${index}-${i}" placeholder="¬∞" min="0" max="360">
                    <input type="number" class="minutes" id="minutes-${index}-${i}" placeholder="'" min="0" max="60">
                    <input type="number" class="seconds" id="seconds-${index}-${i}" placeholder='"' min="0" max="60">
                </td>
                <td class="calculation blue" id="ha-${index}-${i}"></td>
                <td class="average red" id="avg-ha-${index}-${i}"></td>
                <td>
                    <input type="number" id="hd-value-${index}-${i}" placeholder="HD Value" onchange="handleHDInputChange('${table.station}', '${objectToShow}', ${i + 1}, this.value)">
                </td>
            </tr>`;
    }
    return `
        <table id="surveyTable-${index}">
            <tr>
    <th class="lang" data-key="station48">Station</th>
    <th class="lang" data-key="object48">Object</th>
    <th class="lang" data-key="horizontalAngleReading48">Horizontal Angle reading (¬∞ ' ")</th>
    <th class="lang" data-key="horizontalAngle48">Horizontal Angle (¬∞ ' ")</th>
    <th class="lang" data-key="averageHorizontalAngle48">Average Horizontal Angle (¬∞ ' ")</th>
    <th class="lang" data-key="horizontalDistanceMeter48">Horizontal Distance (meter)</th>
</tr>
            ${rowsHTML}
        </table>`;
}
let HDData = {};
function handleHDInputChange(station, object, observationNumber, hdValue) {
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ hdValue ‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    const hdNumber = parseFloat(hdValue);
    if (!isNaN(hdNumber)) {
        addObservation(station, object, observationNumber, hdNumber);
        populateTable();
        displayAverageHDTable();
        updateSwappedAverageHDTable();
        createFinalHDTable();
    }
}
function addObservation(station, object, observationNumber, hdValue) {
    if (!HDData[station]) {
        HDData[station] = {};
    }
    if (!HDData[station][object]) {
        HDData[station][object] = {};
    }
    HDData[station][object][observationNumber] = hdValue;
    console.log('Added HD Value:', hdValue);
}
function populateTable() {
    const table = document.getElementById('hdDataTable');
    // ‡∏•‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Å‡πà‡∏≤‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏Å‡πà‡∏≠‡∏ô‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà
    table.innerHTML = `
      <tr>
        <th>Station</th>
        <th>Object</th>
        <th>Observation Number</th>
        <th>HD Value</th>
      </tr>`;

    for (const station in HDData) {
        for (const object in HDData[station]) {
            for (const observation in HDData[station][object]) {
                const row = table.insertRow();
                row.innerHTML = `
                  <td>${station}</td>
                  <td>${object}</td>
                  <td>${observation}</td>
                  <td>${HDData[station][object][observation]}</td>
                `;
            }
        }
    }
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡πà‡∏≤‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢‡∏Ç‡∏≠‡∏á HD ‡∏ï‡∏≤‡∏° station ‡πÅ‡∏•‡∏∞ object
function calculateAverageHD(station, object) {
  let sum = 0;
  let count = 0;

  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö station ‡πÅ‡∏•‡∏∞ object ‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏
  if (HDData[station] && HDData[station][object]) {
    for (let obs in HDData[station][object]) {
      sum += HDData[station][object][obs];
      count++;
    }
  }

  // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏™‡∏±‡∏á‡πÄ‡∏Å‡∏ï‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢‡∏´‡∏ô‡∏∂‡πà‡∏á‡∏Ñ‡∏£‡∏±‡πâ‡∏á ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡πà‡∏≤‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢
  if (count > 0) {
    return sum / count;
  } else {
    return null; // ‡∏´‡∏£‡∏∑‡∏≠‡∏à‡∏∞ return 0 ‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡πà‡∏≤‡∏≠‡∏∑‡πà‡∏ô‡∏ï‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£
  }
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢ HD ‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á HD Table
function displayAverageHDTable() {
  const averageHDTable = document.getElementById('averageHDDataTable');
  const uniqueStations = [...new Set(pins)]; // ‡∏´‡∏≤ station ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏ã‡πâ‡∏≥‡∏Å‡∏±‡∏ô

  averageHDTable.innerHTML = `
    <tr>
      <th>Station</th>
      <th>Object</th>
      <th>Average HD</th>
    </tr>`;

  uniqueStations.forEach(station => {
    uniqueStations.forEach(object => {
      if (station !== object) {
        const averageHD = calculateAverageHD(station, object);
        if (averageHD !== null) {
          const row = averageHDTable.insertRow();
          row.innerHTML = `
            <td>${station}</td>
            <td>${object}</td>
            <td>${averageHD.toFixed(2)}</td>
          `;
        }
      }
    });
  });
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡πà‡∏≤ HD ‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á HD Table
function displayHDData() {
  const hdTable = document.getElementById('hdDataTable');
  hdTable.classList.remove('hidden'); // ‡∏•‡∏ö class 'hidden' ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏™‡∏î‡∏á‡∏ï‡∏≤‡∏£‡∏≤‡∏á HD
}

function calculateSwappedAverageHD(station1, object1, station2, object2) {
  let avgHD1 = calculateAverageHD(station1, object1);
  let avgHD2 = calculateAverageHD(station2, object2);

  if (avgHD1 != null && avgHD2 != null) {
    return (avgHD1 + avgHD2) / 2;
  } else {
    return null;
  }
}


function updateSwappedAverageHDTable() {
  const table = document.getElementById('swappedAverageHDTable');
  table.innerHTML = `
    <tr>
      <th>Station 1</th>
      <th>Object 1</th>
      <th>Station 2</th>
      <th>Object 2</th>
      <th>Swapped Average HD</th>
    </tr>
  `;

  // ‡∏™‡∏£‡πâ‡∏≤‡∏á Set ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏π‡πà‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÅ‡∏•‡πâ‡∏ß
  let addedPairs = new Set();

  for (let i = 0; i < pins.length; i++) {
    for (let j = 0; j < pins.length; j++) {
      if (i !== j && !addedPairs.has(`${pins[j]}-${pins[i]}`)) {
        const swappedAvgHD = calculateSwappedAverageHD(pins[i], pins[j], pins[j], pins[i]);
        if (swappedAvgHD != null) {
          const newRow = table.insertRow();
          newRow.innerHTML = `
            <td>${pins[i]}</td>
            <td>${pins[j]}</td>
            <td>${pins[j]}</td>
            <td>${pins[i]}</td>
            <td>${swappedAvgHD.toFixed(2)}</td>
          `;
          // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ñ‡∏π‡πà‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÅ‡∏•‡πâ‡∏ß‡πÄ‡∏Ç‡πâ‡∏≤ Set
          addedPairs.add(`${pins[i]}-${pins[j]}`);
        }
      }
    }
  }
}

function createFinalHDTable() {
  const swappedTable = document.getElementById('swappedAverageHDTable');
  const finalTable = document.getElementById('finalHDTable');

  // Clear the final HD table before adding new data
  finalTable.innerHTML = `
    <tr>
      <th>Station</th>
      <th>Distance</th>
    </tr>
  `;

  // Initialize an empty object to keep track of distances
  let distances = {};

  // Loop through each row in the SwappedAverageHD table
  for (let rowIndex = 1; rowIndex < swappedTable.rows.length; rowIndex++) {
    const row = swappedTable.rows[rowIndex];
    const station1 = row.cells[0].textContent.trim();
    const station2 = row.cells[2].textContent.trim();
    const distance = parseFloat(row.cells[4].textContent.trim());

    // Add distance from station1 to station2
    distances[`${station1}-${station2}`] = distance;

    // Add distance from station2 to station1 (for the reverse direction)
    distances[`${station2}-${station1}`] = distance;
  }

  // Create rows for the final HD table using the distances object
  for (const [key, value] of Object.entries(distances)) {
    const newRow = finalTable.insertRow();
    const [station1, station2] = key.split('-');
    newRow.innerHTML = `
      <td>‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏´‡∏°‡∏∏‡∏î${station1}‡πÅ‡∏•‡∏∞${station2}</td>
      <td>${value}</td>
    `;
  }

  // Now, we can create the Deplat table with updated distances
  createDeplatTable();
}

//‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏Ñ‡πà‡∏≤‡∏°‡∏∏‡∏°‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏¥‡∏ô‡∏Å‡∏≥‡∏´‡∏ô‡∏î
function setupInputListenersForTable(tableIndex) {
    const newTable = document.getElementById(`surveyTable-${tableIndex}`);
    newTable.querySelectorAll('.input.yellow input').forEach(input => {
        input.addEventListener('change', event => {
            handleInputChange(event, tableIndex);
            validateInput(event.target.id, event.target.className.includes('degrees') ? 360 : 60);
        });
    });
}
function handleInputChange(event, index) {
    const inputIdParts = event.target.id.split('-');
    const row = parseInt(inputIdParts[2]);

    if (row % 2 !== 0) { // If the row is odd
        const firstInputSuffix = row - 1; // The preceding even row
        const secondInputSuffix = row; // The current odd row

        // Call calculateAndDisplayHA with the appropriate indices
        calculateAndDisplayHA(index, firstInputSuffix, secondInputSuffix);
    } else {
        // Handle even rows as before
        calculateHA(index, row);
    }

    // Common post-calculation tasks
    calculateInnerAngle();
    calculateSumHAFromAllColumns();
}

function calculateHA(tableIndex, row) {
    // Assuming each table has 8 rows and calculations are done between adjacent rows
    if (row % 2 === 0) { // Only calculate when even row index
        calculateAndDisplayHA(tableIndex, row, parseInt(row) + 1);
    }
}

function calculateAndDisplayHA(index, firstInputSuffix, secondInputSuffix) {
    // Retrieve values from input fields for the first and second angle
    const degrees1 = parseInt(document.getElementById(`degrees-${index}-${firstInputSuffix}`).value) || 0;
    const minutes1 = parseInt(document.getElementById(`minutes-${index}-${firstInputSuffix}`).value) || 0;
    const seconds1 = parseInt(document.getElementById(`seconds-${index}-${firstInputSuffix}`).value) || 0;

    const degrees2 = parseInt(document.getElementById(`degrees-${index}-${secondInputSuffix}`).value) || 0;
    const minutes2 = parseInt(document.getElementById(`minutes-${index}-${secondInputSuffix}`).value) || 0;
    const seconds2 = parseInt(document.getElementById(`seconds-${index}-${secondInputSuffix}`).value) || 0;

    // Convert angles to total seconds for easy calculation
    const totalSeconds1 = degrees1 * 3600 + minutes1 * 60 + seconds1;
    const totalSeconds2 = degrees2 * 3600 + minutes2 * 60 + seconds2;

    // Determine the difference in seconds based on the suffix and check if result is negative
    let differenceInSeconds;
    if ((firstInputSuffix % 4 === 0) || (firstInputSuffix % 4 === 3)) { // For the 1st and 3rd pair: second - first
        if (totalSeconds2 - totalSeconds1 < 0) {
            differenceInSeconds = (totalSeconds2 + 360 * 3600) - totalSeconds1;
        } else {
            differenceInSeconds = totalSeconds2 - totalSeconds1;
        }
    } else { // For the 2nd and 4th pair: first - second
        if (totalSeconds1 - totalSeconds2 < 0) {
            differenceInSeconds = (totalSeconds1 + 360 * 3600) - totalSeconds2;
        } else {
            differenceInSeconds = totalSeconds1 - totalSeconds2;
        }
    }

    // Convert the difference back to degrees, minutes, and seconds
    const diffDegrees = Math.floor(Math.abs(differenceInSeconds) / 3600);
    const diffMinutes = Math.floor((Math.abs(differenceInSeconds) % 3600) / 60);
    const diffSeconds = Math.abs(differenceInSeconds) % 60;

    // Update the HA cell with the result
    const resultElement = document.getElementById(`ha-${index}-${firstInputSuffix}`);
    if (resultElement) {
        resultElement.textContent = `${diffDegrees}¬∞ ${diffMinutes}' ${diffSeconds}"`;
    }
    calculateAndDisplayAverageHA(index);
}

// ‡∏´‡∏≤‡∏Ñ‡πà‡∏≤‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢
// ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÅ‡∏•‡∏∞‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢ HA ‡πÇ‡∏î‡∏¢‡∏™‡∏£‡∏∏‡∏õ‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å HA elements ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÅ‡∏•‡∏∞‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á Avg HA cell ‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á
function calculateAndDisplayAverageHA(index) {
  let sumOfSeconds = 0;
  let numberOfAngles = 0;

  // Loop over the HA elements to sum their values in seconds
  for (let i = 0; i <= 7; i += 2) { // Assuming you only have even HA elements i.e., 0, 2, 4, 6
    const haElement = document.getElementById(`ha-${index}-${i}`);
    if (haElement && haElement.textContent) {
      console.log(`HA Element ID: ha-${index}-${i} Value: ${haElement.textContent}`); // Logging for debugging
      const [degrees, minutes, seconds] = haElement.textContent.trim().split(/[¬∞'"]/).map(num => parseInt(num) || 0);
      sumOfSeconds += degrees * 3600 + minutes * 60 + seconds;
      numberOfAngles++;
      
    }
  }

  if (numberOfAngles === 0) return; // Prevent division by zero if no angles are present

  // Calculate the average in seconds
  const averageSeconds = sumOfSeconds / numberOfAngles;

  // Convert the average back to degrees, minutes, and seconds
  const avgDegrees = Math.floor(averageSeconds / 3600);
  const avgMinutes = Math.floor((averageSeconds % 3600) / 60);
  const avgSeconds = Math.floor(averageSeconds % 60);

  // Update the Avg HA cell with the result
  const avgHaElement = document.getElementById(`avg-ha-${index}-0`);
    if (avgHaElement) {
        avgHaElement.textContent = `${avgDegrees}¬∞ ${avgMinutes}' ${avgSeconds}"`;
        
        // Now update the HA values in Step 3
        setAvgHAValueInTable(index);
  }
}
// ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ñ‡πà‡∏≤ HA ‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á Step 3 ‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì
function setAvgHAValueInTable(index) {
    // Fetch the avgHA value from the element with ID 'avg-ha-${index}-0'
    const avgHAElement = document.getElementById(`avg-ha-${index}-0`);
    const avgHAValue = avgHAElement ? avgHAElement.textContent : 'N/A';

    // Assuming Step 3 table has a similar ID setup as the survey tables
    // Update the corresponding HA cell in the Step 3 table
    const step3HaCell = document.getElementById(`step3-ha-${index}`);
    if (step3HaCell) {
        step3HaCell.textContent = avgHAValue;
    }
}
// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏õ‡πâ‡∏≠‡∏ô‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤‡πÉ‡∏´‡πâ‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏ô‡∏Ñ‡πà‡∏≤‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î
function validateInput(id, max) {
    let input = document.getElementById(id);
    if (input && parseInt(input.value) > max) {
        alert('‡πÇ‡∏õ‡∏£‡∏î‡∏£‡∏∞‡∏ö‡∏∏‡∏Ñ‡πà‡∏≤‡πÉ‡∏´‡πâ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á, ' + id.split('-')[0] + ' ‡∏´‡πâ‡∏≤‡∏°‡πÄ‡∏Å‡∏¥‡∏ô ' + max);
        input.value = '';
        input.focus();
    }
}

        // ‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ô‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î


//STEP 3
// ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏™‡∏≥‡∏£‡∏ß‡∏à‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î
function saveSurveyData(tableIndex) {
            // Implement saving of survey data for the specified table
            alert('Survey data saved for table ' + (tableIndex + 1));
        }

// ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ß‡∏±‡∏î // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏ß‡∏±‡∏î‡∏Ñ‡πà‡∏≤‡∏ï‡∏≤‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏°‡∏∏‡∏î (Pins) ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà
function createMeasurementTable() {
    const table = document.getElementById('measurementTable');
    let tableHTML = `<tr><th class="lang" data-key="station">Station</th><th class="lang" data-key="ha">Horizontal Angle (&deg; &apos; &quot;)</th><th class="lang" data-key="correction2">Correction (&deg; &apos; &quot;)</th><th class="lang" data-key="adjustedHA">Adjusted Horizontal Angle (&deg; &apos; &quot;)</th></tr>`;
    pins.forEach((pin, index) => {
        tableHTML += `<tr><td>${pin}</td><td id="step3-ha-${index}" class="AvgHa"></td><td class="corrAngle"></td><td class="adjHA"></td></tr>`;
    });

    if (pins.length === 0) {
        tableHTML += `<tr><td colspan="4" class="lang" data-key="noPinData"></td></tr>`;
    }

    tableHTML += `<tr><td>SUM</td><td class="sumHA"></td><td class="sumCorrectionAngle"></td><td class="sumAdjHa"></td></tr>`;
    tableHTML += `<tr><td>180*(n-2)</td><td class="innerangle"></td></tr>`;
    tableHTML += `<tr><td>ERROR</td><td id="errorangle"></td></tr>`;

    table.innerHTML = tableHTML;
}
        //‡∏ú‡∏•‡∏£‡∏ß‡∏°STEP 3 // ‡πÅ‡∏õ‡∏•‡∏á‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å DMS ‡πÄ‡∏õ‡πá‡∏ô Decimal
    function dmsToDecimal(degrees, minutes, seconds) {
    // Check if the overall value should be negative based on degrees and minutes
    const sign = degrees < 0 || minutes < 0 ? -1 : 1;
    degrees = Math.abs(degrees);
    minutes = Math.abs(minutes);
    return sign * (degrees + minutes / 60 + seconds / 3600);
}
// ‡πÅ‡∏õ‡∏•‡∏á‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å Decimal ‡πÄ‡∏õ‡πá‡∏ô DMS
function decimalToDMS(decimal) {
    const degrees = Math.floor(decimal);
    const minutes = Math.floor((decimal - degrees) * 60);
    const seconds = Math.round(((decimal - degrees) * 60 - minutes) * 60);
    return `${degrees}¬∞ ${minutes}' ${seconds}"`;
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ú‡∏•‡∏£‡∏ß‡∏° HA // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ú‡∏•‡∏£‡∏ß‡∏° HA ‡∏à‡∏≤‡∏Å‡∏ó‡∏∏‡∏Å columns ‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ú‡∏•‡∏£‡∏ß‡∏°‡∏Ç‡∏≠‡∏á HA ‡∏à‡∏≤‡∏Å‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå
function calculateSumHAFromAllColumns() {
    let totalDegrees = 0;
    let totalMinutes = 0;
    let totalSeconds = 0;

    const haElements = document.querySelectorAll('.AvgHa');
    haElements.forEach(el => {
        const parts = el.textContent.trim().match(/(\d+)¬∞ (\d+)' (\d+)"/);
        if (parts) {
            const [_, deg, min, sec] = parts.map(Number);
            totalSeconds += sec;
            totalMinutes += min;
            totalDegrees += deg;
        }
    });

    // Normalize the seconds to minutes, and minutes to degrees
    totalMinutes += Math.floor(totalSeconds / 60);
    totalSeconds %= 60;
    totalDegrees += Math.floor(totalMinutes / 60);
    totalMinutes %= 60;

    // No need to normalize degrees to modulo 360, we want to keep the full sum

    const sumHAElement = document.querySelector('.sumHA');
    if (sumHAElement) {
        sumHAElement.textContent = `${totalDegrees}¬∞ ${totalMinutes}' ${totalSeconds}"`;
    }
    calculateInnerAngle();
}

//‡∏ú‡∏•‡∏£‡∏ß‡∏°‡∏°‡∏∏‡∏°‡∏†‡∏≤‡∏¢‡πÉ‡∏ô // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏°‡∏∏‡∏°‡∏†‡∏≤‡∏¢‡πÉ‡∏ô‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á
function calculateInnerAngle() {
    const numberOfPins = pins.length;
    const innerangleDegrees = 180 * (numberOfPins - 2);

    // Convert the inner angle to DMS format
    const innerangleDMS = convertToDMS(innerangleDegrees);

    // Display the inner angle in DMS format
    const innerangleElement = document.querySelector('.innerangle');
    if (innerangleElement) {
        innerangleElement.textContent = innerangleDMS;
    }
    calculateErrorAngle();
}
// ‡πÅ‡∏õ‡∏•‡∏á‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å Degrees ‡πÄ‡∏õ‡πá‡∏ô DMS
function convertToDMS(degrees) {
    const d = Math.floor(degrees);
    const minfloat = (degrees - d) * 60;
    const m = Math.floor(minfloat);
    const s = Math.round((minfloat - m) * 60);
    return `${d}¬∞ ${m}' ${s}"`;
}
//‡∏Ñ‡πà‡∏≤ Error ‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡πà‡∏≤ Error Angle ‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á
function calculateErrorAngle() {
    const sumHAElement = document.querySelector('.sumHA');
    if (!sumHAElement) return;

    const sumHAParts = sumHAElement.textContent.trim().match(/(\d+)¬∞ (\d+)' (\d+)"/);
    if (!sumHAParts) return;

    const [_, totalDegrees, totalMinutes, totalSeconds] = sumHAParts.map(Number);

    const numberOfPins = pins.length;
    const innerangleDegrees = 180 * (numberOfPins - 2);
    const innerangleTotalSeconds = innerangleDegrees * 3600;
    const sumHATotalSeconds = totalDegrees * 3600 + totalMinutes * 60 + totalSeconds;
    const errorInSeconds = sumHATotalSeconds - innerangleTotalSeconds;

    const errorAngleElement = document.getElementById('errorangle');
    if (errorAngleElement) {
        errorAngleElement.textContent = convertSecondsToDMS(errorInSeconds);
    }
    calculateAverageErrorAngle();
}
let errorSign;
//‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡πà‡∏≤ correction angle ‡∏≠‡∏≠‡∏Å‡∏°‡∏≤ // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡πà‡∏≤ Correction Angle ‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á
function calculateAverageErrorAngle() {
    const errorAngleElement = document.getElementById('errorangle');
    if (!errorAngleElement) return;

    // Extract the error angle parts, with sign included
    const errorDMS = errorAngleElement.textContent.trim();
    const errorSign = errorDMS.startsWith('-') ? -1 : 1;
    const [errorDegrees, errorMinutes, errorSeconds] = errorDMS.replace('-', '').split(/[¬∞'"]/).map(num => parseFloat(num) || 0);
    const errorTotalSeconds = (errorDegrees * 3600) + (errorMinutes * 60) + errorSeconds;

    // Convert the error angle to decimal degrees while preserving the sign
    const errorDecimalDegrees = errorSign * (errorTotalSeconds / 3600);

    // Now, determine the sign for the correction angle based on the sign of the error angle
    const correctionSign = errorDecimalDegrees >= 0 ? -1 : 1;

    // Calculate the average correction angle in seconds, applying the determined sign
    const averageCorrectionSeconds = correctionSign * Math.abs(errorTotalSeconds / pins.length);

    // Convert the average correction angle back to DMS format
    const averageCorrectionDMS = convertSecondsToDMS(averageCorrectionSeconds);

    // Update the correction for each pin
    const correctionElements = document.querySelectorAll('.corrAngle');
    correctionElements.forEach(el => {
        el.textContent = averageCorrectionDMS || '0¬∞ 0\' 0"';
    });

    AdjustHA(); // ‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤ Adjusted HA
    sumCorr();
    updateTableCalculations();
}

// ‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ñ‡πà‡∏≤ Correction ‡πÉ‡∏´‡πâ‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ñ‡πà‡∏≤ Adjusted HA ‡πÅ‡∏•‡∏∞‡∏ú‡∏•‡∏£‡∏ß‡∏°‡∏Ç‡∏≠‡∏á Adjusted HA
//‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡πà‡∏≤ sumCorr // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ú‡∏•‡∏£‡∏ß‡∏°‡∏Ç‡∏≠‡∏á Correction Angle
function sumCorr() {
    let totalCorrSeconds = 0;

    // Loop through each correction cell and sum the seconds, preserving the sign
    document.querySelectorAll('.corrAngle').forEach(cell => {
        const dms = cell.textContent.trim();
        // Check if the correction is negative
        const isNegative = dms.startsWith('-');
        const seconds = dmsToSeconds(dms);
        // If the correction is negative, subtract it from the total, otherwise add it
        totalCorrSeconds += isNegative ? -seconds : seconds;
    });

    // Convert the total seconds to DMS, the function will handle the sign
    const sumDMS = convertSecondsToDMS(totalCorrSeconds);
    const sumCorrCell = document.querySelector('.sumCorrectionAngle');
    if (sumCorrCell) {
        sumCorrCell.textContent = sumDMS;
    }
}

function dmsToSeconds(dms) {
    const parts = dms.match(/(-?\d+)¬∞ (\d+)' (\d+\.?\d*)"/);
    if (!parts) return 0;

    const [_, deg, min, sec] = parts.map(Number);
    // Calculate the total seconds considering the sign
    return deg * 3600 + min * 60 + sec;
}

function newConvertSecondsToDMS(totalSeconds) {
    // This function will be called with a positive number, so no need to handle negative values here
    const degrees = Math.floor(totalSeconds / 3600);
    totalSeconds %= 3600;
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = (totalSeconds % 60).toFixed(2);

    return `${degrees}¬∞ ${minutes}' ${seconds}"`;
}
//‡∏´‡∏≤‡∏Ñ‡πà‡∏≤ adjHa // ‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤ Adjusted HA ‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á
function AdjustHA() {
    // Retrieve the sign from the error angle calculated in calculateAverageErrorAngle
    const errorAngleElement = document.getElementById('errorangle');
    if (!errorAngleElement) return;

    const errorDMS = errorAngleElement.textContent.trim();
    const errorSign = errorDMS.startsWith('-') ? -1 : 1; // Will be -1 if error is negative, 1 if positive

    // Determine the average correction in seconds
    const correctionElements = document.querySelectorAll('.corrAngle');
    const averageCorrectionSeconds = Array.from(correctionElements).reduce((acc, el) => {
        const [corrDegrees, corrMinutes, corrSeconds] = el.textContent.trim().split(/[¬∞'"]/).map(num => parseFloat(num) || 0);
        return acc + ((corrDegrees * 3600) + (corrMinutes * 60) + corrSeconds);
    }, 0) / correctionElements.length;

    // Apply the average correction to each HA value
    const haElements = document.querySelectorAll('.AvgHa');
    haElements.forEach((haElement, index) => {
        const [haDegrees, haMinutes, haSeconds] = haElement.textContent.trim().split(/[¬∞'"]/).map(num => parseFloat(num) || 0);
        const haTotalSeconds = (haDegrees * 3600) + (haMinutes * 60) + haSeconds;

        // Apply the correction based on the sign of the error
        const adjustedTotalSeconds = errorSign === 1 ? haTotalSeconds - averageCorrectionSeconds : haTotalSeconds + averageCorrectionSeconds;

        // Convert the total seconds back to DMS
        const adjustedHADMS = convertSecondsToDMS(adjustedTotalSeconds);

        // Update the Adjusted HA cell in the table
        const adjHaCell = document.querySelectorAll('.adjHA')[index];
        if (adjHaCell) {
            adjHaCell.textContent = adjustedHADMS;
        }
    });

    // Call this function to update the sum of Adjusted HA if needed
    sumAdjHA();
}
function addDMS(dms1, dms2) {
    // Convert both DMS values to seconds
    const seconds1 = dms1[0] * 3600 + dms1[1] * 60 + dms1[2];
    const seconds2 = dms2[0] * 3600 + dms2[1] * 60 + dms2[2];

    // Add the values
    const totalSeconds = seconds1 + seconds2;

    // Convert back to degrees, minutes, seconds
    const degrees = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    const seconds = totalSeconds % 60;

    return [degrees, minutes, seconds];
}

//‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô subtractDMS ‡πÉ‡∏´‡∏°‡πà‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏Ñ‡πà‡∏≤ Correction ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å HA ‡πÅ‡∏•‡∏∞‡∏à‡∏∞‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ô‡πÉ‡∏´‡πâ Adjusted HA ‡∏°‡∏µ‡∏Ñ‡πà‡∏≤‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡πÇ‡∏î‡∏¢‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡πÅ‡∏•‡∏∞‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ô ‡∏à‡∏≤‡∏Å‡∏ô‡∏±‡πâ‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡πÄ‡∏õ‡πá‡∏ô DMS
function subtractDMS(ha, corr) {
    // Convert HA and Correction to seconds
    const haSeconds = ha[0] * 3600 + ha[1] * 60 + ha[2];
    const corrSeconds = corr[0] * 3600 + corr[1] * 60 + corr[2];

    // Subtract Correction seconds from HA seconds
    let adjustedSeconds = haSeconds - corrSeconds;

    // Normalize the adjusted HA seconds to be within the range 0 - 359¬∞ 59' 59"
    while (adjustedSeconds < 0) {
        adjustedSeconds += 360 * 3600;
    }

    // Convert back to degrees, minutes, seconds
    const adjustedDegrees = Math.floor(adjustedSeconds / 3600);
    const adjustedMinutes = Math.floor((adjustedSeconds % 3600) / 60);
    const adjustedSecs = adjustedSeconds % 60;

    return [adjustedDegrees, adjustedMinutes, adjustedSecs];
}

function formatDMS(dms) {
    const [degrees, minutes, seconds] = dms;
    return `${degrees}¬∞ ${Math.abs(minutes)}' ${Math.abs(seconds)}"`;
}

//‡∏´‡∏≤‡∏Ñ‡πà‡∏≤ sumadjHA // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ú‡∏•‡∏£‡∏ß‡∏°‡∏Ç‡∏≠‡∏á Adjusted HA ‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á
function sumAdjHA() {
    let totalAdjHADegrees = 0; // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏à‡∏≤‡∏Å seconds ‡πÄ‡∏õ‡πá‡∏ô degrees ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô

    // Loop through each row in the measurement table
    const rows = document.querySelectorAll('#measurementTable tr');
    rows.forEach((row, index) => {
        if (index > 0 && index < rows.length - 3) { // Skip header, footer, and total rows
            const adjHaElement = row.querySelector('.adjHA');
            if (adjHaElement && adjHaElement.textContent !== 'NaN¬∞ NaN\' NaN"') { // Check if the content is valid
                const adjHa = dmsToDecimal(...adjHaElement.textContent.trim().split(/[¬∞'"]/).map(num => parseFloat(num) || 0));
                // Sum the values directly in degrees
                totalAdjHADegrees += adjHa;
            }
        }
    });

    // Convert the total adjusted HA in degrees back to DMS format
    const totalAdjHADMS = convertDecimalToDMS(totalAdjHADegrees); // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÉ‡∏´‡∏°‡πà‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏á‡∏à‡∏≤‡∏Å degrees ‡πÄ‡∏õ‡πá‡∏ô DMS

    // Update the sumAdjHa element in the table
    const sumAdjHaElement = document.querySelector('.sumAdjHa');
    if (sumAdjHaElement) {
        sumAdjHaElement.textContent = totalAdjHADMS;
    }

    createDeplatTable(); // Call the function to create the deplat table
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏õ‡∏•‡∏á‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å decimal degrees ‡πÑ‡∏õ‡πÄ‡∏õ‡πá‡∏ô DMS format
function convertDecimalToDMS(degrees) {
    const deg = Math.floor(degrees);
    const minFloat = (degrees - deg) * 60;
    const min = Math.floor(minFloat);
    const sec = ((minFloat - min) * 60).toFixed(2);

    // Return the DMS format, but ensure that degrees can go beyond 360
    return `${deg}¬∞ ${min}' ${sec}"`;
}
// ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏á‡∏û‡∏¥‡∏Å‡∏±‡∏î // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏Ç‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ß‡∏±‡∏î Departure ‡πÅ‡∏•‡∏∞ Latitude
function createDeplatTable() {
    let totalDeparture = 0;
    let totalLatitude = 0;
    let distances = getDistancesFromFinalHDTable();
    let tableHTML = `<table>
        <tr>
  <th rowspan="2" class="lang" data-key="station">Station</th>
  <th rowspan="2" class="lang" data-key="adjustedHA">Adjusted HA (¬∞)</th>
  <th rowspan="2" class="lang" data-key="azimuth">Azimuth (¬∞)</th>
  <th rowspan="2" class="lang" data-key="distanceMeter">Distance (meter)</th>
  <th rowspan="2" class="lang" data-key="departure">Departure (meter)</th>
  <th rowspan="2" class="lang" data-key="latitude">Latitude (meter)</th>
  <th colspan="2" class="lang" data-key="correction">Correction</th>
  <th colspan="2" class="lang" data-key="balanced">Balanced</th>
  <th rowspan="2" class="lang" data-key="east">Easting (meter)</th>
  <th rowspan="2" class="lang" data-key="north">Northing (meter)</th>
</tr>
<tr>
  <th class="lang" data-key="departure">Departure (meter)</th>
  <th class="lang" data-key="latitude">Latitude (meter)</th>
  <th class="lang" data-key="departure">Departure (meter)</th>
  <th class="lang" data-key="latitude">Latitude (meter)</th>
</tr>`;

    // Loop through each pin
    pins.forEach((pin, index) => {
        // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ñ‡∏µ‡∏¢‡πå‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏´‡∏°‡∏∏‡∏î‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡πÅ‡∏•‡∏∞‡∏´‡∏°‡∏∏‡∏î‡∏ñ‡∏±‡∏î‡πÑ‡∏õ
        let nextPin = index < pins.length - 1 ? pins[index + 1] : pins[0];
        let distanceKey = `${pin}-${nextPin}`;
        let distanceValue = distances[distanceKey];
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡πÅ‡∏•‡∏∞‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÅ‡∏™‡∏î‡∏á
        let distanceDisplay = distanceValue || "‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•distance";
        
     const adjustedHADecimal = getAdjustedHADecimalFromStep3(pin); // Get Adjusted HA in decimal format
    let isEditable = index === 0; // Check if it is the first row
        tableHTML += `<tr>
                        <td>${pin}</td>
                        <th></th>
                        <th></th>
                        <th></th>
                        <th></th>
                        <th></th>
                        <th></th>
                        <th></th>
                        <th></th>
                        <th></th>
                        <th></th>
                        <th></th>
                        </tr>
                        <tr>
                        <td></td>  
                        <td class="adjHA" data-station="${pin}">${adjustedHADecimal}</td>
                        <td class="azimuthCell" data-station="${pin}"></td>
                        <td><input type="number" id="distance-input-${pin}" class="distanceInput" value="${distanceDisplay}" onchange="calculateDepAndLatForPin('${pin}')"></td>
                        <td id="Departure-${pin}" class="departureCell"></td>
                        <td id="Latitude-${pin}" class="latitudeCell"></td>
                        <td id="Correction-Departure-${pin}" class="Correction-departureCell"></td>
                        <td id="Correction-Latitude-${pin}" class="Correction-latitudeCell"></td>
                        <td id="Balanced-Departure-${pin}" class="Balanced-departureCell"></td>
                        <td id="Balanced-Latitude-${pin}" class="Balanced-latitudeCell"></td>
                        <td id="coordinatesEast-${pin}" class="coordinatesEast"></td>
                        <td id="coordinatesNorth-${pin}" class="coordinatesNorth"></td>
                      </tr>
                      `;
                      if (distanceValue) {
            document.getElementById(`distance-input-${pin}`).value = distanceDisplay;
        } else {
            console.log(`Station ${pin}: ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•distance`);
        }
        // Initialize the totalDeparture and totalLatitude with values from each row if needed
    });
     // ‡∏´‡∏≤‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏´‡∏°‡∏∏‡∏î‡πÅ‡∏£‡∏Å‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏´‡∏°‡∏∏‡∏î‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á
     const firstPin = pins[0];
    const lastPin = pins[pins.length - 1];
    let lastDistanceKey = `${lastPin}-${firstPin}`;
    let lastDistanceValue = distances[lastDistanceKey];
    let lastDistanceDisplay = lastDistanceValue || "‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•distance";
    tableHTML += `<tr>
                    <td>${firstPin}</td>
                        <th></th>
                        <th></th>
                        <th></th>
                        <th></th>
                        <th></th>
                        <th></th>
                        <th></th>
                        <th></th>
                        <th></th>
                        <th></th>
                        <th></th>
                  </tr>`;
    // Add the row for the totals
    tableHTML +=  `<tr>
                    <td colspan="3">Total</td>
                    <td id="totalDistance"></td>
                    <td id="totalDeparture"></td>
                    <td id="totalLatitude"></td>
                    <td id="totalCorrectionDeparture"></td>
                    <td id="totalCorrectionLatitude"></td>
                    <td id="totalBalancedDeparture"></td>
                    <td id="totalBalancedLatitude"></td>
                  </tr>`;

    // Close the table tag
    tableHTML += `</table>`;

    // Inject the table into the 'deplatTable' div
    const deplatTableDiv = document.getElementById('deplatTable');
    if (deplatTableDiv) {
        deplatTableDiv.innerHTML = tableHTML;
    }

    // Now you need to setup event listeners or call functions that will fill in the Departure and Latitude cells
    // and calculate the totals to update the #totalDeparture and #totalLatitude cells
    setupAzimuthCalculation();
    setupDistanceCalculation();
    // Call functions to calculate initial totals if needed
}
// ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏à‡∏≤‡∏Å‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏Ç‡∏±‡πâ‡∏ô‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏à‡∏≤‡∏Å‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
function getDistancesFromFinalHDTable() {
  let distances = {};
  let hasData = false; // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
  const finalTable = document.getElementById('finalHDTable');

  // ‡∏Ç‡πâ‡∏≤‡∏°‡πÅ‡∏ñ‡∏ß‡πÅ‡∏£‡∏Å (‡∏´‡∏±‡∏ß‡∏Ç‡πâ‡∏≠‡∏ï‡∏≤‡∏£‡∏≤‡∏á) ‡πÇ‡∏î‡∏¢‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å index 1
  for (let rowIndex = 1; rowIndex < finalTable.rows.length; rowIndex++) {
    const row = finalTable.rows[rowIndex];
    const stationPair = row.cells[0].textContent.trim();
    const distance = row.cells[1].textContent.trim();

    // ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° '‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏´‡∏°‡∏∏‡∏î' ‡πÅ‡∏•‡∏∞‡πÄ‡∏Å‡πá‡∏ö‡∏Ñ‡πà‡∏≤‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡πÉ‡∏ô‡∏≠‡πá‡∏≠‡∏ö‡πÄ‡∏à‡∏Å‡∏ï‡πå distances
    const stationNames = stationPair.replace('‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏´‡∏°‡∏∏‡∏î', '').split('‡πÅ‡∏•‡∏∞');
    if (stationNames.length === 2 && distance) {
      const key = stationNames[0].trim() + '-' + stationNames[1].trim();
      distances[key] = parseFloat(distance);
      hasData = true; // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£ hasData ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á
    }
  }
  if (!hasData) {
    // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á ‡πÉ‡∏´‡πâ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÉ‡∏ô console.log
    console.log("‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• distance");
  }
  return distances;
}
// ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ Event Listeners
function setupEventListeners() {
    document.getElementById('addEastButton').addEventListener('click', addCoordinateEast);
    document.getElementById('addNorthButton').addEventListener('click', addCoordinateNorth);
}

// ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ñ‡πà‡∏≤ azimuth ‡πÅ‡∏•‡∏∞‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÉ‡∏´‡∏°‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏∏‡∏Å‡∏´‡∏°‡∏∏‡∏î
function addAzimuth() {
    // Get the new azimuth value from the input field
    var newAzimuthValue = parseFloat(document.getElementById('azimuthValue').value);

    // Check if the value is a number and within the valid range
    if (!isNaN(newAzimuthValue) && newAzimuthValue >= 0 && newAzimuthValue < 360) {
        // Select the first azimuth cell in the table
        var firstAzimuthCell = document.querySelector('#deplatTable .azimuthCell');

        // If the cell exists, update its content with the new value
        if (firstAzimuthCell) {
            firstAzimuthCell.textContent = newAzimuthValue.toFixed(5);
            // Clear the input field
            document.getElementById('azimuthValue').value = '';
            // Recalculate azimuths for all stations based on the new value
            recalculateAzimuths(newAzimuthValue);
        }
    } else {
        // Alert the user if the input value is not a valid number
        //showAlert('errorAzimuthValue');
    }
    pins.forEach(pin => {
        calculateDepAndLatForPin(pin);
    });

}
// ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì azimuth ‡πÉ‡∏´‡∏°‡πà‡πÇ‡∏î‡∏¢‡∏≠‡πâ‡∏≤‡∏á‡∏≠‡∏¥‡∏á‡∏à‡∏≤‡∏Å‡∏Ñ‡πà‡∏≤ azimuth ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î
function recalculateAzimuths(startingAzimuth) {
    const azimuthCells = document.querySelectorAll('#deplatTable .azimuthCell');
    const adjustedHACells = document.querySelectorAll('#deplatTable .adjHA');

    // Assuming the first azimuth cell already has the starting azimuth
    let cumulativeAzimuth = startingAzimuth;

    // Start from the second cell (i = 1) since the first is already set
    for (let i = 1; i < azimuthCells.length; i++) {
        let currentHA = parseFloat(adjustedHACells[i].textContent);
        cumulativeAzimuth += currentHA + 180;

        // Adjust for values exceeding 360
        while (cumulativeAzimuth >= 360) {
            cumulativeAzimuth -= 360;
        }

        // Update the azimuth cell
        azimuthCells[i].textContent = cumulativeAzimuth.toFixed(5);
    }
}

//‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏Ñ‡πà‡∏≤ azimuth // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Azimuth ‡∏ï‡∏≤‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏°‡∏∏‡∏î (Pins)  // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Azimuth ‡πÇ‡∏î‡∏¢‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥
function setupAzimuthCalculation() {
    // Loop through each pin and add change event listener to the Azimuth input fields
    pins.forEach((pin, index) => {
        const azimuthInput = document.getElementById(`azimuth-input-${index}`);
        if (azimuthInput) {
            azimuthInput.addEventListener('change', function() {
                calculateAzimuth(index);
            });
        }
    });
}
function parseDMS(input) {
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ input ‡πÑ‡∏°‡πà‡πÄ‡∏õ‡πá‡∏ô null ‡∏´‡∏£‡∏∑‡∏≠ undefined
    if (!input) return NaN;
    const parts = input.match(/(-?\d+)[¬∞ ](\d+)['] (\d+(\.\d+)?)/);
    if (!parts) return NaN;

    const degrees = parseFloat(parts[1]);
    const minutes = parseFloat(parts[2]);
    const seconds = parseFloat(parts[3]);

    return degrees + (minutes / 60) + (seconds / 3600);
}

// This function assumes that the Adjusted HA values and Azimuth input fields have corresponding IDs
// ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Azimuth ‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Azimuth ‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡∏ö‡∏ô UI
function calculateAzimuth() {
    const adjustedHACells = document.querySelectorAll('.adjHA'); // Adjusted HA cells
    const azimuthCells = document.querySelectorAll('.azimuthCell'); // Azimuth cells

    // Start with the first station's Adjusted HA as the initial azimuth
    let cumulativeAzimuth = parseFloat(adjustedHACells[0].textContent);
    azimuthCells[0].textContent = cumulativeAzimuth.toFixed(3); // Set the first station's azimuth

    // Iterate over the remaining stations
    for (let i = 1; i < adjustedHACells.length; i++) {
        // Calculate the azimuth by adding the current Adjusted HA and 180 to the cumulative azimuth
        cumulativeAzimuth += parseFloat(adjustedHACells[i].textContent) + 180;

        // If the cumulative azimuth exceeds 360, subtract 360 to get the correct azimuth
        while (cumulativeAzimuth >= 360) {
            cumulativeAzimuth -= 360;
        }

        // Set the calculated azimuth in the table, formatted to 5 decimal places
        azimuthCells[i].textContent = cumulativeAzimuth.toFixed(3);
    }
}
// Attach the calculateAzimuth function to the Azimuth input field's onchange event for the first station
document.addEventListener('DOMContentLoaded', (event) => {
    const azimuthInputFirstStation = document.getElementById('azimuth-input-0');
    if (azimuthInputFirstStation) {
        azimuthInputFirstStation.addEventListener('change', calculateAzimuth);
    }
});
// Attach the calculateAzimuth function to the Azimuth input field's onchange event
document.addEventListener('DOMContentLoaded', (event) => {
    for (let stationIndex = 1; stationIndex <= 3; stationIndex++) {
        const azimuthInput = document.getElementById(`azimuth-input-${stationIndex}`);
        if (azimuthInput) {
            azimuthInput.addEventListener('change', calculateAzimuth);
        }
    }
});
//‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡πà‡∏≤ Departure
function getAdjustedHADecimalFromStep3(pin) {
    // Find the row for the given pin
    const rows = document.querySelectorAll('#measurementTable tr');
    let adjustedHADecimal = null;
    
    rows.forEach((row, index) => {
        // Skip header, footer, and total rows
        if (index > 0 && index < rows.length - 3) { 
            const stationCell = row.cells[0].textContent;
            if (stationCell === pin) {
                const adjHaCell = row.querySelector('.adjHA');
                if (adjHaCell) {
                    // Assuming adjHaCell contains DMS format
                    const dms = adjHaCell.textContent.trim().split(/[¬∞'"]/).map(num => parseFloat(num) || 0);
                    adjustedHADecimal = dmsToDecimal(...dms).toFixed(5); // Convert to decimal with 5 decimal places
                }
            }
        }
    });
    
    return adjustedHADecimal;
}
//‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡πà‡∏≤ Departure
function setupDistanceCalculation() {
    // ‡∏ß‡∏ô‡∏•‡∏π‡∏õ‡∏ú‡πà‡∏≤‡∏ô‡∏ó‡∏∏‡∏Å‡∏´‡∏°‡∏∏‡∏î
    pins.forEach(pin => {
        // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ event listener ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ü‡∏¥‡∏•‡∏î‡πå distance ‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏´‡∏°‡∏∏‡∏î
        const distanceInput = document.getElementById(`distance-input-${pin}`);
        if (distanceInput) {
            distanceInput.addEventListener('change', function() {
                calculateDepAndLatForPin(pin);
            });
        }
    });
}
// ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Departure ‡πÅ‡∏•‡∏∞ Latitude ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏´‡∏°‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á markers ‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏ö‡∏ô UI
function calculateDepAndLatForPin(pin) {
    // Check if the elements for distance and azimuth exist
    const distanceInput = document.getElementById(`distance-input-${pin}`);
    const azimuthCell = document.querySelector(`.azimuthCell[data-station="${pin}"]`); // Ensure that the selector matches the cell's class and data attribute

    if (distanceInput && azimuthCell) {
        // Retrieve the distance and azimuth for the pin
        const distance = parseFloat(distanceInput.value) || 0;
        const azimuthDegrees = parseFloat(azimuthCell.textContent) || 0;

        // Convert azimuth from degrees to radians
        const azimuthRadians = azimuthDegrees * (Math.PI / 180);

        // Calculate departure and latitude
        const departure = distance * Math.sin(azimuthRadians);
        const latitude = distance * Math.cos(azimuthRadians);

        // Update the values in the table
        const departureCell = document.getElementById(`Departure-${pin}`);
        const latitudeCell = document.getElementById(`Latitude-${pin}`);
        if (departureCell && latitudeCell) {
            departureCell.textContent = departure.toFixed(3);
            latitudeCell.textContent = latitude.toFixed(3);
        }
    } else {
        // Log an error in the console if the elements are not found
        console.error(`Cannot find distance input or azimuth cell for pin: ${pin}`);
    }
    // ‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡πà‡∏≤ Departure ‡πÅ‡∏•‡∏∞ Latitude ‡πÅ‡∏•‡πâ‡∏ß ‡∏Ñ‡∏ß‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ô‡∏µ‡πâ
    calculateCorrections();
    calculateBalancedValues();
}


//‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡πà‡∏≤ correction // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡πà‡∏≤ Correction ‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡πà‡∏≤ correction ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏∏‡∏Å‡∏´‡∏°‡∏∏‡∏î ‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏ö‡∏ô UI
function calculateCorrections() {
    let totalDeparture = 0;
    let totalLatitude = 0;

    // ‡∏ß‡∏ô‡∏•‡∏π‡∏õ‡∏ú‡πà‡∏≤‡∏ô‡∏ó‡∏∏‡∏Å‡∏´‡∏°‡∏∏‡∏î‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏≤‡∏Ñ‡πà‡∏≤‡∏£‡∏ß‡∏°‡∏Ç‡∏≠‡∏á Departure ‡πÅ‡∏•‡∏∞ Latitude
    pins.forEach(pin => {
        const departureCell = document.getElementById(`Departure-${pin}`);
        const latitudeCell = document.getElementById(`Latitude-${pin}`);

        if (departureCell && latitudeCell) {
            // ‡πÅ‡∏õ‡∏•‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡πÅ‡∏•‡∏∞‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡∏Å‡∏±‡∏ö‡∏Ñ‡πà‡∏≤‡∏£‡∏ß‡∏°
            totalDeparture += parseFloat(departureCell.textContent) || 0;
            totalLatitude += parseFloat(latitudeCell.textContent) || 0;
        }
    });

    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡πà‡∏≤‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏±‡∏ö‡πÅ‡∏Å‡πâ‡πÇ‡∏î‡∏¢‡∏Å‡∏≤‡∏£‡πÅ‡∏ö‡πà‡∏á‡∏Ñ‡πà‡∏≤ Error ‡∏≠‡∏≠‡∏Å‡πÄ‡∏õ‡πá‡∏ô‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏´‡∏°‡∏∏‡∏î
    const correctionDeparture = -totalDeparture / pins.length;
    const correctionLatitude = -totalLatitude / pins.length;

    // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ñ‡πà‡∏≤‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏±‡∏ö‡πÅ‡∏Å‡πâ‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á
    pins.forEach(pin => {
        const correctionDepartureCell = document.getElementById(`Correction-Departure-${pin}`);
        const correctionLatitudeCell = document.getElementById(`Correction-Latitude-${pin}`);
        if (correctionDepartureCell && correctionLatitudeCell) {
            correctionDepartureCell.textContent = correctionDeparture.toFixed(3);
            correctionLatitudeCell.textContent = correctionLatitude.toFixed(3);
        }
    });

    // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ñ‡πà‡∏≤‡∏£‡∏ß‡∏°‡∏ó‡∏µ‡πà‡∏ï‡∏≤‡∏£‡∏≤‡∏á
    document.getElementById('totalDeparture').textContent = totalDeparture.toFixed(3);
    document.getElementById('totalLatitude').textContent = totalLatitude.toFixed(3);
}
// ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡πà‡∏≤‡∏™‡∏°‡∏î‡∏∏‡∏•‡∏Ç‡∏≠‡∏á Departure ‡πÅ‡∏•‡∏∞ Latitude ‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡πà‡∏≤ balanced ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö departure ‡πÅ‡∏•‡∏∞ latitude ‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏ö‡∏ô UI
function calculateBalancedValues() {
    pins.forEach(pin => {
        // ‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤‡∏õ‡∏£‡∏±‡∏ö‡πÅ‡∏Å‡πâ Departure ‡πÅ‡∏•‡∏∞ Latitude
        const correctionDeparture = parseFloat(document.getElementById(`Correction-Departure-${pin}`).textContent) || 0;
        const correctionLatitude = parseFloat(document.getElementById(`Correction-Latitude-${pin}`).textContent) || 0;

        // ‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏î‡∏¥‡∏°‡∏Ç‡∏≠‡∏á Departure ‡πÅ‡∏•‡∏∞ Latitude
        const originalDeparture = parseFloat(document.getElementById(`Departure-${pin}`).textContent) || 0;
        const originalLatitude = parseFloat(document.getElementById(`Latitude-${pin}`).textContent) || 0;

        // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡πà‡∏≤‡∏™‡∏°‡∏î‡∏∏‡∏•
        const balancedDeparture = originalDeparture + correctionDeparture;
        const balancedLatitude = originalLatitude + correctionLatitude;

        // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ñ‡πà‡∏≤‡∏™‡∏°‡∏î‡∏∏‡∏•‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á
        document.getElementById(`Balanced-Departure-${pin}`).textContent = balancedDeparture.toFixed(3);
        document.getElementById(`Balanced-Latitude-${pin}`).textContent = balancedLatitude.toFixed(3);
    });
    calculateTotals();
}
// ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ú‡∏•‡∏£‡∏ß‡∏°‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢‡∏Ç‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏ß‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö distance, departure, latitude, ‡πÅ‡∏•‡∏∞‡∏≠‡∏∑‡πà‡∏ô‡πÜ ‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏ö‡∏ô UI
function calculateTotals() {
    // Initialize total variables
    let totalDistance = 0;
    let totalDeparture = 0;
    let totalLatitude = 0;
    let totalCorrectionDeparture = 0;
    let totalCorrectionLatitude = 0;
    let totalBalancedDeparture = 0;
    let totalBalancedLatitude = 0;

    // Get all distance inputs and sum their values
    document.querySelectorAll('.distanceInput').forEach(input => {
        totalDistance += parseFloat(input.value) || 0;
    });

    // Get all departure cells and sum their values
    document.querySelectorAll('.departureCell').forEach(cell => {
        totalDeparture += parseFloat(cell.textContent) || 0;
    });

    // Get all latitude cells and sum their values
    document.querySelectorAll('.latitudeCell').forEach(cell => {
        totalLatitude += parseFloat(cell.textContent) || 0;
    });
    document.querySelectorAll('.Correction-departureCell').forEach(cell => {
        totalCorrectionDeparture += parseFloat(cell.textContent) || 0;
    });
    document.querySelectorAll('.Correction-latitudeCell').forEach(cell => {
        totalCorrectionLatitude += parseFloat(cell.textContent) || 0;
    });
    // Get all balanced departure cells and sum their values
    document.querySelectorAll('.Balanced-departureCell').forEach(cell => {
        totalBalancedDeparture += parseFloat(cell.textContent) || 0;
    });

    // Get all balanced latitude cells and sum their values
    document.querySelectorAll('.Balanced-latitudeCell').forEach(cell => {
        totalBalancedLatitude += parseFloat(cell.textContent) || 0;
    });

    // Update the total cells in the table
    document.getElementById('totalDistance').textContent = totalDistance.toFixed(3);
    document.getElementById('totalDeparture').textContent = totalDeparture.toFixed(3);
    document.getElementById('totalLatitude').textContent = totalLatitude.toFixed(3);
    document.getElementById('totalCorrectionDeparture').textContent = totalCorrectionDeparture.toFixed(3);
    document.getElementById('totalCorrectionLatitude').textContent = totalCorrectionLatitude.toFixed(3);
    document.getElementById('totalBalancedDeparture').textContent = totalBalancedDeparture.toFixed(3);
    document.getElementById('totalBalancedLatitude').textContent = totalBalancedLatitude.toFixed(3);
    calculateCoordinates();
    updateAdditionalTableCalculations();
}
// ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏û‡∏¥‡∏Å‡∏±‡∏î East ‡πÉ‡∏´‡πâ‡∏Å‡∏±‡∏ö‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï UI
function addCoordinateEast() {
    const eastValue = parseFloat(document.getElementById('EastValue').value);
    if (!isNaN(eastValue)) {
        const coordinatesEastCells = document.querySelectorAll('.coordinatesEast');
        // Update the cell for the first pin (assumed to be at index 0)
        if (coordinatesEastCells.length > 0) {
            coordinatesEastCells[0].textContent = eastValue.toFixed(3);
        }
        document.getElementById('EastValue').value = ''; // Clear the input
    } else {
        showAlert('errorEastCoordinate');
    }
    pins.forEach(pin => {
        calculateDepAndLatForPin(pin);
    });
}
// ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏û‡∏¥‡∏Å‡∏±‡∏î North ‡πÉ‡∏´‡πâ‡∏Å‡∏±‡∏ö‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï UI
function addCoordinateNorth() {
    const northValue = parseFloat(document.getElementById('NorthValue').value);
    if (!isNaN(northValue)) {
        const coordinatesNorthCells = document.querySelectorAll('.coordinatesNorth');
        // Update the cell for the first pin (assumed to be at index 0)
        if (coordinatesNorthCells.length > 0) {
            coordinatesNorthCells[0].textContent = northValue.toFixed(3);
        }
        document.getElementById('NorthValue').value = ''; // Clear the input
    } else {
        showAlert('errorNorthCoordinate');
    }
    pins.forEach(pin => {
        calculateDepAndLatForPin(pin);
    });
}
// ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏´‡∏°‡∏∏‡∏î‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡∏ö‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà
function calculateCoordinates() {
    // ‡∏™‡∏°‡∏°‡∏ï‡∏¥‡∏ß‡πà‡∏≤‡∏°‡∏µ array ‡∏Ç‡∏≠‡∏á pins ‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡πá‡∏ö‡∏ä‡∏∑‡πà‡∏≠‡∏Ç‡∏≠‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏µ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
    let easting = parseFloat(document.getElementById(`coordinatesEast-${pins[0]}`).textContent);
    let northing = parseFloat(document.getElementById(`coordinatesNorth-${pins[0]}`).textContent);
    // ‡∏ß‡∏ô‡∏•‡∏π‡∏õ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏à‡∏≤‡∏Å‡∏´‡∏°‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏™‡∏≠‡∏á‡πÑ‡∏õ‡∏à‡∏ô‡∏ñ‡∏∂‡∏á‡∏´‡∏°‡∏∏‡∏î‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢
    for (let i = 1; i < pins.length; i++) {
        const currentPin = pins[i];
        const previousPin = pins[i - 1];

        const balancedDeparture = parseFloat(document.getElementById(`Balanced-Departure-${previousPin}`).textContent) || 0;
        const balancedLatitude = parseFloat(document.getElementById(`Balanced-Latitude-${previousPin}`).textContent) || 0;

        // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡∏Ñ‡πà‡∏≤ Easting ‡πÅ‡∏•‡∏∞ Northing
        easting += balancedDeparture;
        northing += balancedLatitude;

        // ‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡πà‡∏≤‡∏û‡∏¥‡∏Å‡∏±‡∏î‡πÉ‡∏´‡∏°‡πà‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á
        document.getElementById(`coordinatesEast-${currentPin}`).textContent = easting.toFixed(3);
        document.getElementById(`coordinatesNorth-${currentPin}`).textContent = northing.toFixed(3);
    }
}


// Adjust this function to handle negative values and decimal seconds // ‡πÅ‡∏õ‡∏•‡∏á‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡πÄ‡∏õ‡πá‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö DMS (Degree, Minutes, Seconds)
function convertSecondsToDMS(totalSeconds) {
    // Determine the sign based on the totalSeconds
    const sign = totalSeconds < 0 ? '-' : '';
    // Use absolute value to ensure correct conversion
    totalSeconds = Math.abs(totalSeconds);

    const degrees = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    const seconds = (totalSeconds % 60).toFixed(2);

    return `${sign}${degrees}¬∞ ${minutes}' ${seconds}"`;
}
//Step 5
// ‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡πÑ‡∏ü‡∏•‡πå XLSX
function exportTableToXLSX(filename) {
    const wb = XLSX.utils.book_new(); // Create a new workbook
    const ws_data = [];

    const rows = document.querySelectorAll("#surveyTables table tr");

    for (let i = 0; i < rows.length; i++) {
        const row = [], cols = rows[i].querySelectorAll("td, th");

        for (let j = 0; j < cols.length; j++) {
            let value = '';
            if (cols[j].querySelector('input')) {
                const inputs = cols[j].querySelectorAll('input');
                const inputValues = Array.from(inputs).map(input => input.value.trim() === '' ? '0' : input.value);
                value = inputValues.map((val, idx) => val + (idx === 0 ? "¬∞" : idx === 1 ? "'" : '"')).join(" ");
            } else {
                value = cols[j].innerText.trim();
            }
            row.push(value);
        }
        ws_data.push(row);
    }

    const ws = XLSX.utils.aoa_to_sheet(ws_data);
    XLSX.utils.book_append_sheet(wb, ws, "Sheet1"); // Add the worksheet to the workbook

    XLSX.writeFile(wb, filename); // Trigger the download
}
let haDataByStation = {}; // ‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• HA ‡πÅ‡∏¢‡∏Å‡∏ï‡∏≤‡∏° Station

let stationData = {}; // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• HA readings ‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞ station

// ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÑ‡∏ü‡∏•‡πå Excel ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
function handleFileSelect(evt) {
    const file = evt.target.files[0];
    const reader = new FileReader();
    reader.onload = (e) => {
        const data = new Uint8Array(e.target.result);
        const workbook = XLSX.read(data, {type: 'array'});
        const firstSheetName = workbook.SheetNames[0];
        const worksheet = workbook.Sheets[firstSheetName];
        
        // ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô JSON ‡πÅ‡∏•‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö dropdown
        const json = XLSX.utils.sheet_to_json(worksheet, {header:1}); // ‡∏≠‡πà‡∏≤‡∏ô‡πÄ‡∏õ‡πá‡∏ô array
        stationData = {}; // ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Å‡πà‡∏≤
        json.forEach((row, index) => {
            // ‡∏™‡∏°‡∏°‡∏ï‡∏¥‡∏ß‡πà‡∏≤ column ‡πÅ‡∏£‡∏Å‡∏Ñ‡∏∑‡∏≠‡∏ä‡∏∑‡πà‡∏≠ station ‡πÅ‡∏•‡∏∞ column ‡∏ó‡∏µ‡πà‡∏™‡∏≤‡∏°‡∏Ñ‡∏∑‡∏≠ HA reading
            if (row && row[0] && !isNaN(row[0])) {
                if (!stationData[row[0]]) {
                    stationData[row[0]] = []; // ‡∏™‡∏£‡πâ‡∏≤‡∏á array ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö station ‡∏ô‡∏±‡πâ‡∏ô‡πÜ
                }
                // ‡∏™‡∏°‡∏°‡∏ï‡∏¥‡∏ß‡πà‡∏≤ HA reading ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô cell C (index 2)
                stationData[row[0]].push(row[2]);
            }
        });

        updateHADropdown(); // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï dropdown ‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
    };
    reader.readAsArrayBuffer(file);
}

// ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï dropdown ‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å Excel
function updateHADropdown() {
    const haSelect = document.getElementById('haSelect');
    haSelect.innerHTML = '';

    // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å "‡πÑ‡∏°‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å"
    const defaultOption = document.createElement('option');
    defaultOption.value = '';
    defaultOption.textContent = '‡πÑ‡∏°‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å';
    haSelect.appendChild(defaultOption);

    // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞ station
    Object.keys(stationData).forEach(station => {
        const option = document.createElement('option');
        option.value = station;
        option.textContent = `${station}`;
        haSelect.appendChild(option);
    });
}


//Step 5 
var map;
         var markers = [];
         var polygonExists = false;
         var distanceLines = [];
         var showDistances = false;
     
         function initMap() {
           map = new longdo.Map({ placeholder: document.getElementById('map') });
         }

// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡πÅ‡∏õ‡∏•‡∏á‡∏Ñ‡πà‡∏≤ EPSG Code ‡∏ï‡∏≤‡∏°‡∏Ñ‡πà‡∏≤ Easting
function getEpsgCode(eastValue) {
    if (eastValue >= 166021.44 && eastValue <= 833978.56) { // ‡∏ä‡πà‡∏ß‡∏á‡∏Ç‡∏≠‡∏á Zone 47
        return '32647'; // EPSG code for UTM Zone 47N
    } else {
        return '32648'; // EPSG code for UTM Zone 48N as a default
    }
}
// ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏≤‡∏Å‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏Ç‡∏±‡πâ‡∏ô‡∏ó‡∏µ‡πà 5 ‡πÅ‡∏•‡∏∞‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏°‡∏≤‡∏£‡πå‡∏Å‡πÄ‡∏Å‡∏≠‡∏£‡πå‡∏ö‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà
function populateStep5Table() {
    const step4Table = document.getElementById('deplatTable'); // ‡∏ï‡∏≤‡∏£‡∏≤‡∏á Step 4
    const step5Table = document.getElementById('myTable3'); // ‡∏ï‡∏≤‡∏£‡∏≤‡∏á Step 5

    // ‡∏•‡πâ‡∏≤‡∏á‡∏ï‡∏≤‡∏£‡∏≤‡∏á Step 5 ‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà
step5Table.innerHTML = `
<tr>
    <td class="bold-header lang" data-key="pinCoordinates47">Pin Coordinates</td>
    <td class="bold-header lang" data-key="east47">Easting (meter)</td>
    <td class="bold-header lang" data-key="north47">Northing (meter)</td>
    <td class="bold-header lang" data-key="lon47">Longitude ( ¬∞ )</td>
    <td class="bold-header lang" data-key="lat47">Latitude ( ¬∞ )</td>
</tr>
`;

    // ‡∏ß‡∏ô‡∏•‡∏π‡∏õ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å Step 4 ‡πÑ‡∏õ‡∏¢‡∏±‡∏á Step 5
    pins.forEach((pin) => {
        const eastElement = document.getElementById(`coordinatesEast-${pin}`);
        const northElement = document.getElementById(`coordinatesNorth-${pin}`);

        if (eastElement && northElement) {
            const eastValue = parseFloat(eastElement.textContent);
            const northValue = parseFloat(northElement.textContent);
            const epsgCode = getEpsgCode(eastValue);

            proj4.defs(`EPSG:${epsgCode}`, `+proj=utm +zone=${epsgCode.substring(3, 5)} +ellps=WGS84 +datum=WGS84 +units=m +no_defs`);
            const utmCoords = [eastValue, northValue];
            const latLon = proj4(proj4.defs(`EPSG:${epsgCode}`), proj4.defs('EPSG:4326'), utmCoords);

            const newRow = step5Table.insertRow();
            newRow.innerHTML = `
                <td>${pin}</td>
                <td>${eastValue.toFixed(4)}</td>
                <td>${northValue.toFixed(4)}</td>
                <td>${latLon[0].toFixed(15)}</td> <!-- Lon -->
                <td>${latLon[1].toFixed(15)}</td> <!-- Lat -->
            `;
        }
    });
    addMarkerFromTable();
} 
// ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏°‡∏≤‡∏£‡πå‡∏Å‡πÄ‡∏Å‡∏≠‡∏£‡πå‡∏à‡∏≤‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á
function addMarkerFromTable() {
    // ‡∏•‡πâ‡∏≤‡∏á‡∏°‡∏≤‡∏£‡πå‡∏Å‡πÄ‡∏Å‡∏≠‡∏£‡πå‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏ö‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà
    markers.forEach(marker => map.Overlays.remove(marker));
    markers = [];

    // ‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏à‡∏≤‡∏Å‡∏ï‡∏≤‡∏£‡∏≤‡∏á
    const table = document.getElementById('myTable3');
    const rows = table.getElementsByTagName('tr');

    // ‡∏ß‡∏ô‡∏•‡∏π‡∏õ‡∏ú‡πà‡∏≤‡∏ô‡∏ó‡∏∏‡∏Å‡πÅ‡∏ñ‡∏ß‡∏Ç‡∏≠‡∏á‡∏ï‡∏≤‡∏£‡∏≤‡∏á (‡∏¢‡∏Å‡πÄ‡∏ß‡πâ‡∏ô‡πÅ‡∏ñ‡∏ß‡∏´‡∏±‡∏ß‡∏Ç‡πâ‡∏≠)
    for (let i = 1; i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length > 3) {
            const lon = parseFloat(cells[3].innerText);
            const lat = parseFloat(cells[4].innerText);

            if (!isNaN(lon) && !isNaN(lat)) {
                // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏°‡∏≤‡∏£‡πå‡∏Å‡πÄ‡∏Å‡∏≠‡∏£‡πå‡∏ö‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà
                const location = { lon: lon, lat: lat };
                const marker = new longdo.Marker(location, {
                    title: 'Marker ' + i,
                    detail: 'Lon: ' + lon.toFixed(4) + ', Lat: ' + lat.toFixed(4),
                    draggable: false
                });

                // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏°‡∏≤‡∏£‡πå‡∏Å‡πÄ‡∏Å‡∏≠‡∏£‡πå‡∏•‡∏á‡∏ö‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà
                map.Overlays.add(marker);
                markers.push(marker);
                zoomToMarker(marker);
            }
        }
    }
}
// Optionally, you can define the zoomToMarker function if not already defined // ‡∏ã‡∏π‡∏°‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏°‡∏≤‡∏£‡πå‡∏Å‡πÄ‡∏Å‡∏≠‡∏£‡πå‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î
function zoomToMarker(marker) {
  map.location(marker.location());
  map.zoom(15);
}
// ‡∏•‡πâ‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á // ‡∏•‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á
function clearDistanceCalculation() {
       // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÇ‡∏Ñ‡πâ‡∏î‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡πâ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏•‡∏ö‡∏û‡∏¥‡∏Å‡∏±‡∏î
       const distanceTable = document.getElementById("distanceTable");
       while (distanceTable.rows.length > 1) {
         distanceTable.deleteRow(1);
       }
     
       distanceLines.forEach(function (line) {
         map.Overlays.remove(line);
       });
       distanceLines = [];
     
       showDistances = false;
       document.getElementById("distanceResult").innerHTML = "";
     }

// ‡∏•‡πâ‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà // ‡∏•‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà
function clearAreaCalculation() {
       // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÇ‡∏Ñ‡πâ‡∏î‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡πâ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏•‡∏ö‡∏û‡∏¥‡∏Å‡∏±‡∏î
       document.getElementById("resultDisplay").innerHTML = "";
     
       // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏•‡πâ‡∏≤‡∏á‡∏Ñ‡πà‡∏≤ area
       area = 0;
     
       const existingPolygon = map.Overlays.list().find(overlay => overlay instanceof longdo.Polygon);
       if (existingPolygon) {
         map.Overlays.remove(existingPolygon);
       }
     }
// ‡∏™‡∏•‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏Ç‡∏≠‡∏á Polygon ‡∏ö‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà     // ‡∏™‡∏•‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏Ç‡∏≠‡∏á Polygon ‡∏ö‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà
function togglePolygon() {
       const polygonButton = document.getElementById("polygonButton");
       if (polygonExists) {
         const existingPolygon = map.Overlays.list().find(overlay => overlay instanceof longdo.Polygon);
         if (existingPolygon) {
           map.Overlays.remove(existingPolygon);
         }
         polygonExists = false;
       } else {
         const polygonPoints = markers.map(marker => ({ lon: marker.location().lon, lat: marker.location().lat }));
         var AreaShow = document.getElementById('resultDisplay').innerHTML; // Use innerHTML instead of value
         var polygonArea = calculatePolygonArea('resultDisplay');
         var polygon = new longdo.Polygon(polygonPoints, {
           title: `‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà`,
           detail: +resultDisplay,
           label: '‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà',
           lineWidth: 2,
           lineColor: 'rgba(0, 0, 0, 1)',
           fillColor: 'rgba(255, 0, 0, 0.4)',
           editable: false,
           weight: longdo.OverlayWeight.Top
         });
         map.Overlays.add(polygon);
         polygonExists = true;
       }
     }
  // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏•‡∏∞‡∏™‡∏•‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏Ç‡∏≠‡∏á Polygon   // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏•‡∏∞‡∏™‡∏•‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏Ç‡∏≠‡∏á Polygon 
function calculateAreaAndTogglePolygon() {
       const resultDisplay = document.getElementById("resultDisplay");
     
       if (resultDisplay.innerHTML.trim() !== "") {
         resultDisplay.innerHTML = "";
     
         // Check if there is a Polygon and remove it
         const existingPolygon = map.Overlays.list().find(overlay => overlay instanceof longdo.Polygon);
         if (existingPolygon) {
           map.Overlays.remove(existingPolygon);
         }
     
         // ‡∏õ‡∏¥‡∏î‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà
         clearAreaCalculation();
       } else {
         calculateArea();  // Make sure calculateArea function is working correctly
         togglePolygon();
       }
     }
// ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì    
function distance() {
           if (showDistances) {
             distanceLines.forEach(function (line) {
               map.Overlays.remove(line);
             });
             distanceLines = [];
             showDistances = false;
     
             document.getElementById("distanceResult").innerHTML = "";
     
             // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á
             clearDistanceTable();
           } else {
             if (markers.length >= 2) {
               const distances = [];
               for (let i = 0; i < markers.length - 1; i++) {
                 const pair = { from: markers[i], to: markers[i + 1] };
                 const displacement = distanceBetweenMarkers(pair.from.location(), pair.to.location());
                 const line = new longdo.Polyline([pair.from.location(), pair.to.location()], {
                   lineWidth: 2,
                   lineColor: 'red'
                 });
                 map.Overlays.add(line);
                 distanceLines.push(line);
     
                 distances.push({
                   from: pair.from.title,
                   to: pair.to.title,
                   distance: displacement
                 });
     
                 // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏•‡∏á‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á
                 updateDistanceTable(pair.from.title, pair.to.title, displacement.toFixed(2));
               }
     
               // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢ (‡∏à‡∏≤‡∏Å‡∏à‡∏∏‡∏î‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏à‡∏∏‡∏î‡πÅ‡∏£‡∏Å)
               const lastPair = { from: markers[markers.length - 1], to: markers[0] };
               const lastDisplacement = distanceBetweenMarkers(lastPair.from.location(), lastPair.to.location());
               const lastLine = new longdo.Polyline([lastPair.from.location(), lastPair.to.location()], {
                 lineWidth: 2,
                 lineColor: 'red'
               });
               map.Overlays.add(lastLine);
               distanceLines.push(lastLine);
     
               distances.push({
                 from: lastPair.from.title,
                 to: lastPair.to.title,
                 distance: lastDisplacement
               });
     
               // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢‡∏•‡∏á‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á
               updateDistanceTable(lastPair.from.title, lastPair.to.title, lastDisplacement.toFixed(2));
     
               showDistances = true;
             } else {
                showAlert('minimumTwoCoordinatesAlert');
             }
           }
         }
// ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏°‡∏≤‡∏£‡πå‡∏Å‡πÄ‡∏Å‡∏≠‡∏£‡πå   // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á markers ‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï UI
function distanceBetweenMarkers(location1, location2) {
           return longdo.Util.distance([location1, location2]);
         }
 // ‡∏•‡πâ‡∏≤‡∏á‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á    
function clearDistanceTable() {
           const table = document.getElementById("distanceTable");
           while (table.rows.length > 1) {
             table.deleteRow(1);
           }
         }
  // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á   
function updateDistanceTable(from, to, distance) {
       const table = document.getElementById("distanceTable");
       const newRow = table.insertRow();
       const cell1 = newRow.insertCell(0);
       const cell2 = newRow.insertCell(1);
       const cell3 = newRow.insertCell(2);
       cell1.innerHTML = `<td>${from}</td>`;
       cell2.innerHTML = `<td>${to}</td>`;
       cell3.innerHTML = `<td data-key="distanceUnit">${distance} <span class="lang-unit">‡πÄ‡∏°‡∏ï‡∏£</span></td>`;
     }
     
// ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô calculatePolygonArea ‡πÅ‡∏•‡∏∞ calculateArea 
// ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà Polygon
function calculatePolygonArea(coords) {
       let area = 0;
     
       for (let i = 0; i < coords.length; i++) {
         const x1 = coords[i].east;
         const y1 = coords[i].north;
         const x2 = coords[(i + 1) % coords.length].east;
         const y2 = coords[(i + 1) % coords.length].north;
     
         area += x1 * y2 - x2 * y1;
       }
     
       return Math.abs(area) / 2;
     }
 // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏≤‡∏Å‡∏°‡∏≤‡∏£‡πå‡∏Å‡πÄ‡∏Å‡∏≠‡∏£‡πå‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå    
function calculateArea() {
  const resultDisplay = document.getElementById("resultDisplay");
  const currentLang = document.body.getAttribute('data-lang'); // ‡∏î‡∏∂‡∏á‡∏†‡∏≤‡∏©‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô

  if (markers.length < 3) {
    // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏´‡∏°‡∏∏‡∏î‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏û‡∏≠
    resultDisplay.textContent = languageData[currentLang]['areaCalculationWarning'];
    return;
  }

  const utmCoords = markers.map(marker => {
    const lon = parseFloat(marker.location().lon);
    const lat = parseFloat(marker.location().lat);

    let zone;
    if (lon >= 96 && lon <= 102) {
      zone = 47;
    } else if (lon > 102 && lon <= 108) {
      zone = 48;
    } else {
      // ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏û‡∏¥‡∏Å‡∏±‡∏î‡πÑ‡∏°‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏Ç‡∏≠‡∏ö‡πÄ‡∏Ç‡∏ï‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î
      alert(languageData[currentLang]['longitudeOutOfRange']);
      return;
    }

    const utmZone = `+proj=utm +zone=${zone} +ellps=WGS84 +datum=WGS84 +units=m +no_defs`;
    const utmCoords = proj4(utmZone, [lon, lat]);

    return { east: utmCoords[0], north: utmCoords[1] };
  }).filter(coord => coord != null); // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡πà‡∏≤ `null` ‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏≠‡∏á

  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ utmCoords ‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏õ‡∏•‡πà‡∏≤‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏≠‡∏á
  if (utmCoords.length < 3) {
    return;
  }

  const area = calculatePolygonArea(utmCoords);
  window.latestAreaCalculationResult = area.toFixed(4); // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì

  // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà
  resultDisplay.textContent = `${languageData[currentLang]['areaResultPrefix']} ${window.latestAreaCalculationResult} ${languageData[currentLang]['areaUnit']}`;
}

     //End step 5
// ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏´‡∏°‡∏∏‡∏î‡∏ï‡∏≤‡∏°‡∏ä‡∏∑‡πà‡∏≠‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï UI // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏´‡∏°‡∏∏‡∏î‡πÇ‡∏î‡∏¢‡∏≠‡πâ‡∏≤‡∏á‡∏≠‡∏¥‡∏á‡∏à‡∏≤‡∏Å‡∏ä‡∏∑‡πà‡∏≠
function addPinByName(pinName) {
    if (pinName && !pins.includes(pinName)) {
        pins.push(pinName); // Add the pin name to your pins array
        updateUI(); // Update the UI to reflect changes
    } else {
        // Handle the case where the pin is a duplicate or invalid
        console.error(`Pin "${pinName}" is already added or is invalid.`);
    }

}
//export step 1  // ‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏õ‡∏¢‡∏±‡∏á Excel // ‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏õ‡∏¢‡∏±‡∏á Excel
function exportToExcel() {
    // ‡∏™‡∏£‡πâ‡∏≤‡∏á Workbook ‡πÉ‡∏´‡∏°‡πà
    var wb = XLSX.utils.book_new();

    // ‡∏™‡∏£‡πâ‡∏≤‡∏á Array ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å‡∏ï‡∏≤‡∏£‡∏≤‡∏á
    var ws_data = [['‡∏•‡∏≥‡∏î‡∏±‡∏ö', '‡∏ä‡∏∑‡πà‡∏≠‡∏´‡∏°‡∏∏‡∏î']]; // ‡∏´‡∏±‡∏ß‡∏ï‡∏≤‡∏£‡∏≤‡∏á

    // Loop ‡∏ú‡πà‡∏≤‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏´‡∏°‡∏∏‡∏î‡πÅ‡∏•‡∏∞‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏õ‡πÉ‡∏ô ws_data
    pins.forEach(function(pin, index) {
        ws_data.push([index + 1, pin]); // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏ó‡∏µ‡πà 1
    });

    // ‡∏™‡∏£‡πâ‡∏≤‡∏á Worksheet ‡∏à‡∏≤‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô ws_data
    var ws = XLSX.utils.aoa_to_sheet(ws_data);

    // ‡πÄ‡∏û‡∏¥‡πà‡∏° Worksheet ‡∏ô‡∏µ‡πâ‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏õ‡πÉ‡∏ô Workbook
    XLSX.utils.book_append_sheet(wb, ws, "Pins");

    // ‡∏ï‡∏±‡πâ‡∏á‡∏ä‡∏∑‡πà‡∏≠‡πÑ‡∏ü‡∏•‡πå
    var filename = 'pins_export.xlsx';

    // ‡πÄ‡∏≠‡πá‡∏Å‡∏ã‡πå‡∏û‡∏≠‡∏£‡πå‡∏ï Workbook ‡πÄ‡∏õ‡πá‡∏ô‡πÑ‡∏ü‡∏•‡πå Excel
    XLSX.writeFile(wb, filename);
}
// ‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å‡∏ó‡∏∏‡∏Å‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡πÑ‡∏ü‡∏•‡πå Excel ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß // ‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏≠‡∏á‡∏ó‡∏∏‡∏Å step ‡πÑ‡∏õ‡∏¢‡∏±‡∏á Excel
function exportStepsToExcel() {
    const wb = XLSX.utils.book_new(); // Create a new workbook

    // Step 1: Export pins
    const ws1_data = [['‡∏•‡∏≥‡∏î‡∏±‡∏ö', '‡∏ä‡∏∑‡πà‡∏≠‡∏´‡∏°‡∏∏‡∏î']];
    pins.forEach((pin, index) => {
        ws1_data.push([index + 1, pin]);
    });
    const ws1 = XLSX.utils.aoa_to_sheet(ws1_data);
    XLSX.utils.book_append_sheet(wb, ws1, "Step 1 Pins");

    // Step 2: Export survey data ensuring units are included for ha reading and avg ha
    const ws2_data = [];
const rows = document.querySelectorAll("#surveyTables table tr");
for (let i = 0; i < rows.length; i++) {
    const row = [], cols = rows[i].querySelectorAll("td, th");

    for (let j = 0; j < cols.length; j++) {
        let value = '';
        if (cols[j].querySelector('input')) {
            const inputs = cols[j].querySelectorAll('input');
            const inputValues = Array.from(inputs).map(input => {
                // Check for degrees, minutes, and seconds
                if (input.className.includes('degrees') || input.className.includes('minutes') || input.className.includes('seconds')) {
                    // Ensure the unit is added (¬∞, ', ") accordingly
                    let unit = '';
                    if (input.className.includes('degrees')) unit = '¬∞';
                    if (input.className.includes('minutes')) unit = "'";
                    if (input.className.includes('seconds')) unit = '"';
                    return input.value.trim() === '' ? '0' + unit : input.value + unit;
                } else {
                    return input.value.trim() === '' ? '0' : input.value;
                }
            });
            value = inputValues.join(" ");
        } else {
            value = cols[j].innerText.trim();
        }
        row.push(value);
    }
    ws2_data.push(row);
}
    
    const ws2 = XLSX.utils.aoa_to_sheet(ws2_data);
    XLSX.utils.book_append_sheet(wb, ws2, "Step 2 Survey Data");
        // Step 3: Export measurement data
        const ws3_data = [];
    const measurementRows = document.querySelectorAll("#measurementTable tr");
    for (let i = 0; i < measurementRows.length; i++) {
        const row = [], cols = measurementRows[i].querySelectorAll("td, th");

        for (let j = 0; j < cols.length; j++) {
            let value = '';
            if (cols[j].querySelector('input')) {
                const inputs = cols[j].querySelectorAll('input');
                const inputValues = Array.from(inputs).map(input => input.value.trim() === '' ? '0' : input.value);
                value = inputValues.join(" ");
            } else {
                value = cols[j].innerText.trim();
            }
            row.push(value);
        }
        ws3_data.push(row);
    }
    const ws3 = XLSX.utils.aoa_to_sheet(ws3_data);
    XLSX.utils.book_append_sheet(wb, ws3, "Step 3 Measurement Data");

    // Step 4: Export deplat (departure and latitude) data
    const ws4_data = [['Station', 'Adjusted HA', 'Azimuth', 'Distance', 'Departure', 'Latitude', 'Correction Departure', 'Correction Latitude', 'Balanced Departure', 'Balanced Latitude', 'East', 'North']];

// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÉ‡∏´‡πâ‡πÅ‡∏ô‡πà‡πÉ‡∏à‡∏ß‡πà‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÅ‡∏ñ‡∏ß‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å tbody ‡∏Ç‡∏≠‡∏á‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô
const deplatRows = document.querySelectorAll("#deplatTable tbody tr");

// ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ß‡∏ô‡∏•‡∏π‡∏õ‡∏ó‡∏µ‡πà i = 1 ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ç‡πâ‡∏≤‡∏°‡∏´‡∏±‡∏ß‡∏Ç‡πâ‡∏≠‡∏ï‡∏≤‡∏£‡∏≤‡∏á (header) ‡∏ñ‡πâ‡∏≤‡∏´‡∏±‡∏ß‡∏Ç‡πâ‡∏≠‡∏ñ‡∏π‡∏Å‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏°‡∏≤‡∏î‡πâ‡∏ß‡∏¢
for (let i = 2; i < deplatRows.length; i++) {
    const row = [], cols = deplatRows[i].querySelectorAll("td, th");
    for (let j = 0; j < cols.length; j++) {
        // Check if there is an input and get its value
        const input = cols[j].querySelector('input');
        let value = input ? input.value : cols[j].innerText.trim();
        row.push(value);
    }
    ws4_data.push(row);
}

    const ws4 = XLSX.utils.aoa_to_sheet(ws4_data);
    XLSX.utils.book_append_sheet(wb, ws4, "Step 4 Deplat Data");
// Step 5: Export data from myTable3, myTable1, myTable2
const ws5_data = []; // Initialize the array for Step 5 data

// Define a function to extract data from a table
const extractTableData = (selector) => {
    const tableRows = document.querySelectorAll(selector + " tr");
    const tableData = [];
    for (let i = 0; i < tableRows.length; i++) {
        const row = [], cols = tableRows[i].querySelectorAll("td, th");
        for (let j = 0; j < cols.length; j++) {
            const input = cols[j].querySelector('input');
            const value = input ? input.value : cols[j].innerText.trim();
            row.push(value);
        }
        tableData.push(row);
    }
    return tableData;
};

// Extract data from each table and add to the worksheet data
const myTable3Data = extractTableData("#myTable3");
const distanceTable = extractTableData("#distanceTable");
const myTable2Data = extractTableData("#myTable2");

// Concatenate all table data
ws5_data.push(...myTable3Data, ...distanceTable, ...myTable2Data);

//Step 5 export
const ws5 = XLSX.utils.aoa_to_sheet(ws5_data);
XLSX.utils.book_append_sheet(wb, ws5, "Step 5 Additional Data");

  // Export the workbook
  const filename = 'Survey_data.xlsx';
    XLSX.writeFile(wb, filename);
}



// ‡∏õ‡∏∏‡πà‡∏°‡∏Å‡∏î STEP // ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÉ‡∏ô UI // ‡πÄ‡∏õ‡∏¥‡∏î‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÉ‡∏ô UI ‡πÅ‡∏•‡∏∞‡πÇ‡∏´‡∏•‡∏î‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡∏´‡∏≤‡∏Å‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 5
// ‡πÄ‡∏õ‡∏¥‡∏î‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÉ‡∏ô UI ‡πÅ‡∏•‡∏∞‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡∏´‡∏≤‡∏Å‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 5
function showStep(stepNumber) {
  for (let i = 1; i <= 5; i++) {
    const step = document.getElementById(`step${i}`);
    step.style.display = i === stepNumber ? 'block' : 'none';

    // Check if we're moving to Step 5
    if (i === 5 && stepNumber === 5) {
      initMap();
      populateStep5Table();
    }
  }
  //addAzimuth();
}
// ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï UI ‡πÉ‡∏´‡πâ‡∏™‡∏≠‡∏î‡∏Ñ‡∏•‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï UI ‡πÇ‡∏î‡∏¢‡∏£‡∏ß‡∏° ‡∏£‡∏ß‡∏°‡∏ñ‡∏∂‡∏á‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ú‡∏•‡∏£‡∏ß‡∏°
function updateUI() {
    updatePinTable();
    updateDropdowns();
    createMeasurementTable();
    calculateSumHAFromAllColumns();
    createDeplatTable();
    setupAzimuthCalculation();
    getDistancesFromFinalHDTable();
}
// ‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡πà‡∏≤‡∏á‡πÜ ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏ß‡πá‡∏ö‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô ‡πÄ‡∏ä‡πà‡∏ô ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï UI
window.onload = function() {
    updateUI();
}
</script>


<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.16.9/xlsx.full.min.js"></script>

</body>
</html>